AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for CodeCommit Git Workflows and Policies'

Parameters:
  RepositoryName:
    Type: String
    Description: Name of the CodeCommit repository
    Default: enterprise-app
    MinLength: 1
    MaxLength: 100
    AllowedPattern: ^[a-zA-Z0-9._-]+$
    ConstraintDescription: Repository name must contain only alphanumeric characters, periods, hyphens, and underscores
  
  RepositoryDescription:
    Type: String
    Description: Description for the CodeCommit repository
    Default: Enterprise application with Git workflow automation
    MaxLength: 1000
  
  TeamLeadUserArn:
    Type: String
    Description: ARN of the team lead user for approval rules
    Default: arn:aws:iam::123456789012:user/team-lead
    AllowedPattern: ^arn:aws:iam::[0-9]{12}:user/.+$
    ConstraintDescription: Must be a valid IAM user ARN
  
  SeniorDev1UserArn:
    Type: String
    Description: ARN of the first senior developer for approval rules
    Default: arn:aws:iam::123456789012:user/senior-dev-1
    AllowedPattern: ^arn:aws:iam::[0-9]{12}:user/.+$
    ConstraintDescription: Must be a valid IAM user ARN
  
  SeniorDev2UserArn:
    Type: String
    Description: ARN of the second senior developer for approval rules
    Default: arn:aws:iam::123456789012:user/senior-dev-2
    AllowedPattern: ^arn:aws:iam::[0-9]{12}:user/.+$
    ConstraintDescription: Must be a valid IAM user ARN
  
  NotificationEmail:
    Type: String
    Description: Email address for workflow notifications
    Default: dev-team@example.com
    AllowedPattern: ^[^\s@]+@[^\s@]+\.[^\s@]+$
    ConstraintDescription: Must be a valid email address
  
  Environment:
    Type: String
    Description: Environment name for resource tagging
    Default: development
    AllowedValues:
      - development
      - staging
      - production
  
  ProjectName:
    Type: String
    Description: Project name for resource tagging
    Default: enterprise-app
    MinLength: 1
    MaxLength: 50

Conditions:
  # Create email subscription only if a valid email is provided
  CreateEmailSubscription: !Not [!Equals [!Ref NotificationEmail, dev-team@example.com]]

Resources:
  # CodeCommit Repository
  GitRepository:
    Type: AWS::CodeCommit::Repository
    Properties:
      RepositoryName: !Sub '${RepositoryName}-${AWS::StackName}'
      RepositoryDescription: !Ref RepositoryDescription
      Code:
        S3:
          Bucket: !Ref InitialCodeBucket
          Key: initial-code.zip
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName
        - Key: ManagedBy
          Value: codecommit-automation
        - Key: StackName
          Value: !Ref AWS::StackName

  # S3 Bucket for initial repository code
  InitialCodeBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'codecommit-initial-code-${AWS::AccountId}-${AWS::Region}-${AWS::StackName}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
          - Id: DeleteIncompleteMultipartUploads
            Status: Enabled
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 7
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  # SNS Topics for Notifications
  PullRequestTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub 'codecommit-pull-requests-${AWS::StackName}'
      DisplayName: CodeCommit Pull Request Notifications
      KmsMasterKeyId: alias/aws/sns
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  MergeTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub 'codecommit-merges-${AWS::StackName}'
      DisplayName: CodeCommit Merge Notifications
      KmsMasterKeyId: alias/aws/sns
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  QualityGateTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub 'codecommit-quality-gates-${AWS::StackName}'
      DisplayName: CodeCommit Quality Gate Notifications
      KmsMasterKeyId: alias/aws/sns
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  SecurityAlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub 'codecommit-security-alerts-${AWS::StackName}'
      DisplayName: CodeCommit Security Alert Notifications
      KmsMasterKeyId: alias/aws/sns
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  # SNS Email Subscriptions (conditional)
  PullRequestEmailSubscription:
    Type: AWS::SNS::Subscription
    Condition: CreateEmailSubscription
    Properties:
      TopicArn: !Ref PullRequestTopic
      Protocol: email
      Endpoint: !Ref NotificationEmail

  QualityGateEmailSubscription:
    Type: AWS::SNS::Subscription
    Condition: CreateEmailSubscription
    Properties:
      TopicArn: !Ref QualityGateTopic
      Protocol: email
      Endpoint: !Ref NotificationEmail

  SecurityAlertEmailSubscription:
    Type: AWS::SNS::Subscription
    Condition: CreateEmailSubscription
    Properties:
      TopicArn: !Ref SecurityAlertTopic
      Protocol: email
      Endpoint: !Ref NotificationEmail

  # IAM Role for Lambda Functions
  CodeCommitAutomationRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'CodeCommitAutomationRole-${AWS::StackName}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CodeCommitAutomationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # CloudWatch Logs permissions
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
              
              # CodeCommit permissions
              - Effect: Allow
                Action:
                  - codecommit:GetRepository
                  - codecommit:GetBranch
                  - codecommit:GetCommit
                  - codecommit:GetDifferences
                  - codecommit:GetPullRequest
                  - codecommit:ListPullRequests
                  - codecommit:GetMergeCommit
                  - codecommit:GetMergeConflicts
                  - codecommit:GetMergeOptions
                  - codecommit:PostCommentForPullRequest
                  - codecommit:UpdatePullRequestTitle
                  - codecommit:UpdatePullRequestDescription
                  - codecommit:ListBranches
                  - codecommit:GetFile
                  - codecommit:GetFolder
                Resource: !GetAtt GitRepository.Arn
              
              # SNS permissions
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource:
                  - !Ref PullRequestTopic
                  - !Ref MergeTopic
                  - !Ref QualityGateTopic
                  - !Ref SecurityAlertTopic
              
              # CloudWatch metrics permissions
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: '*'
                Condition:
                  StringEquals:
                    'cloudwatch:namespace':
                      - 'CodeCommit/PullRequests'
                      - 'CodeCommit/QualityGates'
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  # Lambda Function for Pull Request Automation
  PullRequestAutomationFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'codecommit-automation-pull-request-${AWS::StackName}'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt CodeCommitAutomationRole.Arn
      Timeout: 300
      MemorySize: 256
      Environment:
        Variables:
          PULL_REQUEST_TOPIC_ARN: !Ref PullRequestTopic
          MERGE_TOPIC_ARN: !Ref MergeTopic
          QUALITY_GATE_TOPIC_ARN: !Ref QualityGateTopic
          REPOSITORY_NAME: !GetAtt GitRepository.Name
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          from datetime import datetime
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          codecommit = boto3.client('codecommit')
          sns = boto3.client('sns')
          cloudwatch = boto3.client('cloudwatch')
          
          def lambda_handler(event, context):
              """Handle CodeCommit pull request events"""
              try:
                  logger.info(f"Received event: {json.dumps(event)}")
                  
                  # Parse event details
                  detail = event.get('detail', {})
                  event_name = detail.get('event')
                  repository_name = detail.get('repositoryName')
                  pull_request_id = detail.get('pullRequestId')
                  
                  if not all([event_name, repository_name, pull_request_id]):
                      logger.error("Missing required event details")
                      return {'statusCode': 400, 'body': 'Invalid event format'}
                  
                  # Get pull request details
                  pr_response = codecommit.get_pull_request(pullRequestId=pull_request_id)
                  pull_request = pr_response['pullRequest']
                  
                  # Extract pull request information
                  pr_info = {
                      'pullRequestId': pull_request_id,
                      'title': pull_request['title'],
                      'description': pull_request.get('description', ''),
                      'authorArn': pull_request['authorArn'],
                      'sourceReference': pull_request['pullRequestTargets'][0]['sourceReference'],
                      'destinationReference': pull_request['pullRequestTargets'][0]['destinationReference'],
                      'repositoryName': repository_name,
                      'creationDate': pull_request['creationDate'].isoformat(),
                      'pullRequestStatus': pull_request['pullRequestStatus']
                  }
                  
                  # Handle different pull request events
                  if event_name == 'pullRequestCreated':
                      return handle_pull_request_created(pr_info)
                  elif event_name == 'pullRequestSourceBranchUpdated':
                      return handle_pull_request_updated(pr_info)
                  elif event_name == 'pullRequestStatusChanged':
                      return handle_pull_request_status_changed(pr_info, detail)
                  elif event_name == 'pullRequestMergeStatusUpdated':
                      return handle_merge_status_updated(pr_info, detail)
                  else:
                      logger.info(f"Unhandled event type: {event_name}")
                      return {'statusCode': 200, 'body': 'Event acknowledged'}
                      
              except Exception as e:
                  logger.error(f"Error processing pull request event: {str(e)}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
          
          def handle_pull_request_created(pr_info):
              """Handle new pull request creation"""
              logger.info(f"New pull request created: {pr_info['pullRequestId']}")
              
              # Validate pull request
              validation_results = validate_pull_request(pr_info)
              
              # Send notification
              message = f"""
          ðŸ”„ New Pull Request Created
          
          Repository: {pr_info['repositoryName']}
          Pull Request: #{pr_info['pullRequestId']}
          Title: {pr_info['title']}
          Author: {pr_info['authorArn'].split('/')[-1]}
          Source: {pr_info['sourceReference']}
          Target: {pr_info['destinationReference']}
          
          Validation Results:
          {format_validation_results(validation_results)}
          
          Created: {pr_info['creationDate']}
              """
              
              sns.publish(
                  TopicArn=os.environ['PULL_REQUEST_TOPIC_ARN'],
                  Subject=f'New PR: {pr_info["title"]}',
                  Message=message
              )
              
              # Record metrics
              cloudwatch.put_metric_data(
                  Namespace='CodeCommit/PullRequests',
                  MetricData=[
                      {
                          'MetricName': 'PullRequestsCreated',
                          'Value': 1,
                          'Unit': 'Count',
                          'Dimensions': [
                              {'Name': 'Repository', 'Value': pr_info['repositoryName']}
                          ]
                      }
                  ]
              )
              
              return {'statusCode': 200, 'body': 'Pull request creation handled'}
          
          def handle_pull_request_updated(pr_info):
              """Handle pull request source branch updates"""
              logger.info(f"Pull request updated: {pr_info['pullRequestId']}")
              return {'statusCode': 200, 'body': 'Pull request update handled'}
          
          def handle_pull_request_status_changed(pr_info, detail):
              """Handle pull request status changes"""
              old_status = detail.get('oldPullRequestStatus')
              new_status = detail.get('newPullRequestStatus')
              
              logger.info(f"Pull request status changed: {old_status} -> {new_status}")
              return {'statusCode': 200, 'body': 'Status change handled'}
          
          def handle_merge_status_updated(pr_info, detail):
              """Handle merge status updates"""
              merge_status = detail.get('mergeStatus')
              
              if merge_status == 'MERGED':
                  logger.info(f"Pull request merged: {pr_info['pullRequestId']}")
                  
                  # Send merge notification
                  message = f"""
          âœ… Pull Request Merged
          
          Repository: {pr_info['repositoryName']}
          Pull Request: #{pr_info['pullRequestId']}
          Title: {pr_info['title']}
          Merged to: {pr_info['destinationReference']}
          
          The changes have been successfully merged.
                  """
                  
                  sns.publish(
                      TopicArn=os.environ['MERGE_TOPIC_ARN'],
                      Subject=f'PR Merged: {pr_info["title"]}',
                      Message=message
                  )
              
              return {'statusCode': 200, 'body': 'Merge status update handled'}
          
          def validate_pull_request(pr_info):
              """Validate pull request against quality gates"""
              results = {
                  'branch_naming': check_branch_naming(pr_info['sourceReference']),
                  'title_format': check_title_format(pr_info['title']),
                  'description_present': bool(pr_info['description'].strip()),
                  'target_branch': check_target_branch(pr_info['destinationReference']),
                  'all_passed': True
              }
              
              # Set overall result
              results['all_passed'] = all(results[key] for key in results if key != 'all_passed')
              return results
          
          def check_branch_naming(branch_name):
              """Check if branch follows naming convention"""
              valid_prefixes = ['feature/', 'bugfix/', 'hotfix/', 'release/', 'chore/']
              return any(branch_name.startswith(prefix) for prefix in valid_prefixes)
          
          def check_title_format(title):
              """Check if title follows format guidelines"""
              return (len(title.strip()) > 5 and len(title) < 100 and title[0].isupper())
          
          def check_target_branch(target_branch):
              """Check if target branch is appropriate"""
              return (target_branch in ['develop', 'main', 'master'] or 
                      target_branch.startswith('release/'))
          
          def format_validation_results(results):
              """Format validation results for display"""
              status_emoji = "âœ…" if results['all_passed'] else "âŒ"
              
              checks = [
                  f"{'âœ…' if results['branch_naming'] else 'âŒ'} Branch naming convention",
                  f"{'âœ…' if results['title_format'] else 'âŒ'} Title format",
                  f"{'âœ…' if results['description_present'] else 'âŒ'} Description present",
                  f"{'âœ…' if results['target_branch'] else 'âŒ'} Target branch valid"
              ]
              
              return f"{status_emoji} Overall: {'PASSED' if results['all_passed'] else 'FAILED'}\n" + "\n".join(checks)
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  # Lambda Function for Quality Gate Automation
  QualityGateAutomationFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'codecommit-automation-quality-gate-${AWS::StackName}'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt CodeCommitAutomationRole.Arn
      Timeout: 300
      MemorySize: 512
      Environment:
        Variables:
          QUALITY_GATE_TOPIC_ARN: !Ref QualityGateTopic
          SECURITY_ALERT_TOPIC_ARN: !Ref SecurityAlertTopic
          REPOSITORY_NAME: !GetAtt GitRepository.Name
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          from datetime import datetime
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          codecommit = boto3.client('codecommit')
          sns = boto3.client('sns')
          cloudwatch = boto3.client('cloudwatch')
          
          def lambda_handler(event, context):
              """Handle repository triggers for quality gate automation"""
              try:
                  logger.info(f"Received event: {json.dumps(event)}")
                  
                  # Parse CodeCommit trigger event
                  records = event.get('Records', [])
                  
                  for record in records:
                      # Extract trigger information
                      trigger_info = extract_trigger_info(record)
                      if not trigger_info:
                          continue
                      
                      # Run quality checks
                      quality_results = run_quality_checks(trigger_info)
                      
                      # Process results
                      process_quality_results(trigger_info, quality_results)
                  
                  return {'statusCode': 200, 'body': 'Quality checks completed'}
                  
              except Exception as e:
                  logger.error(f"Error in quality gate automation: {str(e)}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
          
          def extract_trigger_info(record):
              """Extract trigger information from CodeCommit event"""
              try:
                  # Parse CodeCommit event record
                  event_source_arn = record.get('eventSourceARN', '')
                  repository_name = event_source_arn.split(':')[-1] if event_source_arn else ''
                  
                  codecommit_data = record.get('codecommit', {})
                  references = codecommit_data.get('references', [])
                  
                  if not references:
                      return None
                  
                  ref = references[0]
                  return {
                      'repository_name': repository_name,
                      'branch': ref.get('ref', '').replace('refs/heads/', ''),
                      'commit_id': ref.get('commit'),
                      'event_type': 'push'
                  }
                  
              except Exception as e:
                  logger.error(f"Error extracting trigger info: {str(e)}")
                  return None
          
          def run_quality_checks(trigger_info):
              """Run comprehensive quality checks"""
              results = {
                  'repository': trigger_info['repository_name'],
                  'branch': trigger_info['branch'],
                  'commit_id': trigger_info['commit_id'],
                  'timestamp': datetime.utcnow().isoformat(),
                  'checks': {},
                  'overall_result': 'PASSED'
              }
              
              try:
                  # Simulate quality checks (in production, implement actual checks)
                  results['checks'] = {
                      'lint_check': {'passed': True, 'message': 'Code linting passed'},
                      'security_scan': {'passed': True, 'message': 'No security issues found'},
                      'test_coverage': {'passed': True, 'coverage_percentage': 85.5},
                      'dependency_check': {'passed': True, 'message': 'No vulnerable dependencies'}
                  }
                  
                  # Calculate overall result
                  all_passed = all(check.get('passed', False) for check in results['checks'].values())
                  results['overall_result'] = 'PASSED' if all_passed else 'FAILED'
                  
              except Exception as e:
                  logger.error(f"Error running quality checks: {str(e)}")
                  results['overall_result'] = 'ERROR'
                  results['error'] = str(e)
              
              return results
          
          def process_quality_results(trigger_info, results):
              """Process and communicate quality check results"""
              try:
                  # Record metrics
                  record_quality_metrics(results)
                  
                  # Send notifications for failures
                  if results['overall_result'] == 'FAILED':
                      send_quality_failure_notification(trigger_info, results)
                  elif results['overall_result'] == 'PASSED':
                      send_quality_success_notification(trigger_info, results)
                  
              except Exception as e:
                  logger.error(f"Error processing quality results: {str(e)}")
          
          def record_quality_metrics(results):
              """Record quality metrics to CloudWatch"""
              try:
                  cloudwatch.put_metric_data(
                      Namespace='CodeCommit/QualityGates',
                      MetricData=[
                          {
                              'MetricName': 'QualityChecksResult',
                              'Value': 1 if results['overall_result'] == 'PASSED' else 0,
                              'Unit': 'Count',
                              'Dimensions': [
                                  {'Name': 'Repository', 'Value': results['repository']},
                                  {'Name': 'Branch', 'Value': results['branch']}
                              ]
                          }
                      ]
                  )
              except Exception as e:
                  logger.error(f"Error recording metrics: {str(e)}")
          
          def send_quality_failure_notification(trigger_info, results):
              """Send notification for quality check failures"""
              try:
                  message = f"""
          ðŸš¨ Quality Gates Failed
          
          Repository: {results['repository']}
          Branch: {results['branch']}
          Commit: {results['commit_id'][:8]}
          
          Please address these issues before merging.
          Timestamp: {results['timestamp']}
                  """
                  
                  sns.publish(
                      TopicArn=os.environ['QUALITY_GATE_TOPIC_ARN'],
                      Subject=f'Quality Gates Failed: {results["repository"]}',
                      Message=message
                  )
                  
              except Exception as e:
                  logger.error(f"Error sending failure notification: {str(e)}")
          
          def send_quality_success_notification(trigger_info, results):
              """Send notification for quality check success"""
              try:
                  # Only send success notifications for important branches
                  important_branches = ['main', 'master', 'develop']
                  
                  if results['branch'] not in important_branches:
                      return
                  
                  message = f"""
          âœ… Quality Gates Passed
          
          Repository: {results['repository']}
          Branch: {results['branch']}
          Commit: {results['commit_id'][:8]}
          
          All quality checks passed successfully.
          Timestamp: {results['timestamp']}
                  """
                  
                  sns.publish(
                      TopicArn=os.environ['QUALITY_GATE_TOPIC_ARN'],
                      Subject=f'Quality Gates Passed: {results["repository"]}',
                      Message=message
                  )
                  
              except Exception as e:
                  logger.error(f"Error sending success notification: {str(e)}")
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  # Lambda Function for Branch Protection
  BranchProtectionFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'codecommit-automation-branch-protection-${AWS::StackName}'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt CodeCommitAutomationRole.Arn
      Timeout: 300
      MemorySize: 256
      Environment:
        Variables:
          REPOSITORY_NAME: !GetAtt GitRepository.Name
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          codecommit = boto3.client('codecommit')
          
          def lambda_handler(event, context):
              """Automated branch protection enforcement"""
              try:
                  repository_name = event.get('repository_name', os.environ.get('REPOSITORY_NAME'))
                  if not repository_name:
                      return {'statusCode': 400, 'body': 'Repository name required'}
                  
                  # Enforce branch protection rules
                  protection_results = enforce_branch_protection(repository_name)
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(protection_results)
                  }
                  
              except Exception as e:
                  logger.error(f"Error in branch protection: {str(e)}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
          
          def enforce_branch_protection(repository_name):
              """Enforce branch protection policies"""
              results = {
                  'repository': repository_name,
                  'protected_branches': [],
                  'approval_rules_checked': [],
                  'actions_taken': []
              }
              
              try:
                  # List branches in repository
                  branches_response = codecommit.list_branches(repositoryName=repository_name)
                  branches = branches_response.get('branches', [])
                  
                  # Define protected branches
                  protected_branches = ['main', 'master', 'develop']
                  
                  for branch in branches:
                      if branch in protected_branches:
                          results['protected_branches'].append(branch)
                          check_approval_rules(repository_name, branch, results)
                  
                  return results
                  
              except Exception as e:
                  logger.error(f"Error enforcing branch protection: {str(e)}")
                  results['error'] = str(e)
                  return results
          
          def check_approval_rules(repository_name, branch, results):
              """Check and ensure approval rules for protected branch"""
              try:
                  results['approval_rules_checked'].append({
                      'branch': branch,
                      'status': 'checked',
                      'has_approval_rules': True  # Simulated
                  })
                  
              except Exception as e:
                  logger.error(f"Error checking approval rules: {str(e)}")
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  # EventBridge Rule for Pull Request Events
  PullRequestEventRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub 'codecommit-pull-request-events-${AWS::StackName}'
      Description: Capture CodeCommit pull request events
      EventPattern:
        source:
          - aws.codecommit
        detail-type:
          - CodeCommit Pull Request State Change
        detail:
          repositoryName:
            - !GetAtt GitRepository.Name
      State: ENABLED
      Targets:
        - Arn: !GetAtt PullRequestAutomationFunction.Arn
          Id: PullRequestAutomationTarget

  # Permission for EventBridge to invoke Lambda
  PullRequestEventRuleLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref PullRequestAutomationFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt PullRequestEventRule.Arn

  # Permission for CodeCommit to invoke Quality Gate Lambda
  QualityGateLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref QualityGateAutomationFunction
      Action: lambda:InvokeFunction
      Principal: codecommit.amazonaws.com
      SourceArn: !GetAtt GitRepository.Arn

  # Approval Rule Template
  ApprovalRuleTemplate:
    Type: AWS::CodeCommit::ApprovalRuleTemplate
    Properties:
      ApprovalRuleTemplateName: !Sub 'enterprise-approval-template-${AWS::StackName}'
      ApprovalRuleTemplateDescription: Standard approval rules for enterprise repositories
      ApprovalRuleTemplateContent: !Sub |
        {
          "Version": "2018-11-08",
          "DestinationReferences": ["refs/heads/main", "refs/heads/master", "refs/heads/develop"],
          "Statements": [
            {
              "Type": "Approvers",
              "NumberOfApprovalsNeeded": 2,
              "ApprovalPoolMembers": [
                "${TeamLeadUserArn}",
                "${SeniorDev1UserArn}",
                "${SeniorDev2UserArn}"
              ]
            }
          ]
        }

  # Associate Approval Rule Template with Repository
  ApprovalRuleTemplateAssociation:
    Type: AWS::CodeCommit::ApprovalRuleTemplateAssociation
    Properties:
      ApprovalRuleTemplateName: !Ref ApprovalRuleTemplate
      RepositoryName: !GetAtt GitRepository.Name

  # CloudWatch Dashboard for Git Workflow Monitoring
  GitWorkflowDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: !Sub 'Git-Workflow-${AWS::StackName}'
      DashboardBody: !Sub |
        {
          "widgets": [
            {
              "type": "metric",
              "x": 0,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  ["CodeCommit/PullRequests", "PullRequestsCreated", "Repository", "${GitRepository}"],
                  [".", "PullRequestsMerged", ".", "."],
                  [".", "PullRequestsClosed", ".", "."]
                ],
                "period": 300,
                "stat": "Sum",
                "region": "${AWS::Region}",
                "title": "Pull Request Activity"
              }
            },
            {
              "type": "metric",
              "x": 12,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  ["CodeCommit/QualityGates", "QualityChecksResult", "Repository", "${GitRepository}"]
                ],
                "period": 300,
                "stat": "Average",
                "region": "${AWS::Region}",
                "title": "Quality Gate Success Rate",
                "yAxis": {
                  "left": {
                    "min": 0,
                    "max": 1
                  }
                }
              }
            },
            {
              "type": "log",
              "x": 0,
              "y": 6,
              "width": 24,
              "height": 6,
              "properties": {
                "query": "SOURCE '/aws/lambda/${PullRequestAutomationFunction}'\n| fields @timestamp, @message\n| filter @message like /Pull request/\n| sort @timestamp desc\n| limit 20",
                "region": "${AWS::Region}",
                "title": "Recent Pull Request Events"
              }
            }
          ]
        }

Outputs:
  RepositoryName:
    Description: Name of the created CodeCommit repository
    Value: !GetAtt GitRepository.Name
    Export:
      Name: !Sub '${AWS::StackName}-RepositoryName'

  RepositoryCloneUrlHttp:
    Description: HTTPS clone URL for the repository
    Value: !GetAtt GitRepository.CloneUrlHttp
    Export:
      Name: !Sub '${AWS::StackName}-RepositoryCloneUrlHttp'

  RepositoryCloneUrlSsh:
    Description: SSH clone URL for the repository
    Value: !GetAtt GitRepository.CloneUrlSsh
    Export:
      Name: !Sub '${AWS::StackName}-RepositoryCloneUrlSsh'

  RepositoryArn:
    Description: ARN of the CodeCommit repository
    Value: !GetAtt GitRepository.Arn
    Export:
      Name: !Sub '${AWS::StackName}-RepositoryArn'

  PullRequestTopicArn:
    Description: ARN of the SNS topic for pull request notifications
    Value: !Ref PullRequestTopic
    Export:
      Name: !Sub '${AWS::StackName}-PullRequestTopicArn'

  MergeTopicArn:
    Description: ARN of the SNS topic for merge notifications
    Value: !Ref MergeTopic
    Export:
      Name: !Sub '${AWS::StackName}-MergeTopicArn'

  QualityGateTopicArn:
    Description: ARN of the SNS topic for quality gate notifications
    Value: !Ref QualityGateTopic
    Export:
      Name: !Sub '${AWS::StackName}-QualityGateTopicArn'

  SecurityAlertTopicArn:
    Description: ARN of the SNS topic for security alert notifications
    Value: !Ref SecurityAlertTopic
    Export:
      Name: !Sub '${AWS::StackName}-SecurityAlertTopicArn'

  PullRequestAutomationFunctionName:
    Description: Name of the pull request automation Lambda function
    Value: !Ref PullRequestAutomationFunction
    Export:
      Name: !Sub '${AWS::StackName}-PullRequestAutomationFunctionName'

  QualityGateAutomationFunctionName:
    Description: Name of the quality gate automation Lambda function
    Value: !Ref QualityGateAutomationFunction
    Export:
      Name: !Sub '${AWS::StackName}-QualityGateAutomationFunctionName'

  BranchProtectionFunctionName:
    Description: Name of the branch protection Lambda function
    Value: !Ref BranchProtectionFunction
    Export:
      Name: !Sub '${AWS::StackName}-BranchProtectionFunctionName'

  ApprovalRuleTemplateName:
    Description: Name of the approval rule template
    Value: !Ref ApprovalRuleTemplate
    Export:
      Name: !Sub '${AWS::StackName}-ApprovalRuleTemplateName'

  DashboardUrl:
    Description: URL to the CloudWatch dashboard
    Value: !Sub 'https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${GitWorkflowDashboard}'
    Export:
      Name: !Sub '${AWS::StackName}-DashboardUrl'

  LambdaExecutionRoleArn:
    Description: ARN of the Lambda execution role
    Value: !GetAtt CodeCommitAutomationRole.Arn
    Export:
      Name: !Sub '${AWS::StackName}-LambdaExecutionRoleArn'

  EventBridgeRuleName:
    Description: Name of the EventBridge rule for pull request events
    Value: !Ref PullRequestEventRule
    Export:
      Name: !Sub '${AWS::StackName}-EventBridgeRuleName'