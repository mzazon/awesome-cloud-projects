AWSTemplateFormatVersion: '2010-09-09'
Description: 'Container Security Scanning Pipeline with ECR and Third-Party Tools - Comprehensive security scanning solution with multi-layered vulnerability detection'

# ==============================================================================
# PARAMETERS
# ==============================================================================

Parameters:
  ProjectName:
    Type: String
    Default: container-security-pipeline
    Description: 'Name prefix for all resources created by this template'
    MinLength: 3
    MaxLength: 50
    AllowedPattern: '^[a-zA-Z][a-zA-Z0-9-]*$'
    ConstraintDescription: 'Must start with a letter and contain only alphanumeric characters and hyphens'

  ECRRepositoryName:
    Type: String
    Default: secure-app-repository
    Description: 'Name of the ECR repository for container images'
    MinLength: 2
    MaxLength: 256
    AllowedPattern: '^[a-z0-9]+(?:[._-][a-z0-9]+)*$'
    ConstraintDescription: 'Must be lowercase alphanumeric with periods, underscores, or hyphens'

  EnableEnhancedScanning:
    Type: String
    Default: 'true'
    AllowedValues: ['true', 'false']
    Description: 'Enable ECR enhanced scanning with Amazon Inspector'

  ScanningFrequency:
    Type: String
    Default: CONTINUOUS_SCAN
    AllowedValues: [CONTINUOUS_SCAN, SCAN_ON_PUSH]
    Description: 'Frequency of enhanced scanning - continuous or on-push only'

  VulnerabilityThresholds:
    Type: String
    Default: CRITICAL:0,HIGH:5,MEDIUM:10
    Description: 'Vulnerability count thresholds for alerts (format: CRITICAL:0,HIGH:5,MEDIUM:10)'

  NotificationEmail:
    Type: String
    Description: 'Email address for security alert notifications'
    AllowedPattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    ConstraintDescription: 'Must be a valid email address'

  SlackWebhookUrl:
    Type: String
    Default: ''
    Description: 'Optional Slack webhook URL for notifications (leave empty if not using Slack)'
    NoEcho: true

  SnykToken:
    Type: String
    Default: ''
    Description: 'Optional Snyk API token for third-party scanning (leave empty if not using Snyk)'
    NoEcho: true

  PrismaCloudDetails:
    Type: String
    Default: ''
    Description: 'Optional Prisma Cloud details in format: console_url,username,password (leave empty if not using Prisma Cloud)'
    NoEcho: true

  CodeBuildComputeType:
    Type: String
    Default: BUILD_GENERAL1_MEDIUM
    AllowedValues: 
      - BUILD_GENERAL1_SMALL
      - BUILD_GENERAL1_MEDIUM
      - BUILD_GENERAL1_LARGE
      - BUILD_GENERAL1_2XLARGE
    Description: 'CodeBuild compute type for security scanning jobs'

  RetentionInDays:
    Type: Number
    Default: 30
    MinValue: 1
    MaxValue: 365
    Description: 'Log retention period in days for CloudWatch logs'

# ==============================================================================
# CONDITIONS
# ==============================================================================

Conditions:
  EnableEnhancedScanningCondition: !Equals [!Ref EnableEnhancedScanning, 'true']
  HasSlackWebhook: !Not [!Equals [!Ref SlackWebhookUrl, '']]
  HasSnykToken: !Not [!Equals [!Ref SnykToken, '']]
  HasPrismaCloudDetails: !Not [!Equals [!Ref PrismaCloudDetails, '']]
  IsContinuousScanning: !Equals [!Ref ScanningFrequency, 'CONTINUOUS_SCAN']

# ==============================================================================
# RESOURCES
# ==============================================================================

Resources:

  # ------------------------------------------------------------------------------
  # ECR Repository with Enhanced Scanning
  # ------------------------------------------------------------------------------

  ECRRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Ref ECRRepositoryName
      ImageScanningConfiguration:
        ScanOnPush: true
      EncryptionConfiguration:
        EncryptionType: AES256
      ImageTagMutability: MUTABLE
      LifecyclePolicy:
        LifecyclePolicyText: !Sub |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep last 10 production images",
                "selection": {
                  "tagStatus": "tagged",
                  "tagPrefixList": ["prod"],
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              },
              {
                "rulePriority": 2,
                "description": "Keep last 5 staging images",
                "selection": {
                  "tagStatus": "tagged",
                  "tagPrefixList": ["staging"],
                  "countType": "imageCountMoreThan",
                  "countNumber": 5
                },
                "action": {
                  "type": "expire"
                }
              },
              {
                "rulePriority": 3,
                "description": "Delete untagged images older than 1 day",
                "selection": {
                  "tagStatus": "untagged",
                  "countType": "sinceImagePushed",
                  "countUnit": "days",
                  "countNumber": 1
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-repository'
        - Key: Project
          Value: !Ref ProjectName
        - Key: Purpose
          Value: 'Container Security Scanning Pipeline'

  # Enhanced Scanning Configuration (Registry Level)
  EnhancedScanningConfiguration:
    Type: AWS::ECR::RegistryScanningConfiguration
    Condition: EnableEnhancedScanningCondition
    Properties:
      ScanType: ENHANCED
      Rules:
        - ScanFrequency: !Ref ScanningFrequency
          RepositoryFilters:
            - Filter: !Ref ECRRepositoryName
              FilterType: WILDCARD

  # ------------------------------------------------------------------------------
  # IAM Roles and Policies
  # ------------------------------------------------------------------------------

  # CodeBuild Service Role
  CodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-codebuild-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryPowerUser
      Policies:
        - PolicyName: CodeBuildSecurityScanningPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${ProjectName}*'
              - Effect: Allow
                Action:
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                  - ecr:GetAuthorizationToken
                  - ecr:InitiateLayerUpload
                  - ecr:UploadLayerPart
                  - ecr:CompleteLayerUpload
                  - ecr:PutImage
                  - ecr:DescribeRepositories
                  - ecr:DescribeImages
                  - ecr:DescribeImageScanFindings
                  - ecr:GetRepositoryPolicy
                Resource: '*'
              - Effect: Allow
                Action:
                  - inspector2:ListFindings
                  - inspector2:GetFindings
                Resource: '*'
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: 
                  - !Ref SnykTokenSecret
                  - !Ref PrismaCloudSecret
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource: !Sub 'arn:aws:events:${AWS::Region}:${AWS::AccountId}:event-bus/default'
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-codebuild-role'
        - Key: Project
          Value: !Ref ProjectName

  # Lambda Execution Role
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SecurityScanProcessingPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${ProjectName}*'
              - Effect: Allow
                Action:
                  - securityhub:BatchImportFindings
                  - securityhub:GetFindings
                  - securityhub:UpdateFindings
                Resource: '*'
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource: 
                  - !Ref SecurityAlertsTopic
                  - !Ref SlackNotificationTopic
              - Effect: Allow
                Action:
                  - ecr:DescribeImageScanFindings
                  - ecr:DescribeImages
                  - ecr:DescribeRepositories
                Resource: '*'
              - Effect: Allow
                Action:
                  - inspector2:ListFindings
                  - inspector2:GetFindings
                Resource: '*'
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource: !GetAtt SecurityFindingsTable.Arn
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-lambda-role'
        - Key: Project
          Value: !Ref ProjectName

  # EventBridge Rule Execution Role
  EventBridgeExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-eventbridge-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: EventBridgeLambdaInvokePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt SecurityScanProcessorFunction.Arn
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-eventbridge-role'
        - Key: Project
          Value: !Ref ProjectName

  # ------------------------------------------------------------------------------
  # Secrets Manager for Third-Party Tool Credentials
  # ------------------------------------------------------------------------------

  SnykTokenSecret:
    Type: AWS::SecretsManager::Secret
    Condition: HasSnykToken
    Properties:
      Name: !Sub '${ProjectName}-snyk-token'
      Description: 'Snyk API token for container security scanning'
      SecretString: !Sub |
        {
          "token": "${SnykToken}"
        }
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-snyk-token'
        - Key: Project
          Value: !Ref ProjectName

  PrismaCloudSecret:
    Type: AWS::SecretsManager::Secret
    Condition: HasPrismaCloudDetails
    Properties:
      Name: !Sub '${ProjectName}-prisma-cloud'
      Description: 'Prisma Cloud credentials for container security scanning'
      SecretString: !Sub |
        {
          "console_url": "${PrismaCloudDetails}",
          "username": "placeholder",
          "password": "placeholder"
        }
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-prisma-cloud'
        - Key: Project
          Value: !Ref ProjectName

  # ------------------------------------------------------------------------------
  # CodeBuild Project for Security Scanning
  # ------------------------------------------------------------------------------

  SecurityScanningProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub '${ProjectName}-security-scanning'
      Description: 'Multi-stage container security scanning with third-party tools'
      ServiceRole: !GetAtt CodeBuildServiceRole.Arn
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: !Ref CodeBuildComputeType
        Image: aws/codebuild/standard:5.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: AWS_DEFAULT_REGION
            Value: !Ref AWS::Region
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: ECR_REPOSITORY_NAME
            Value: !Ref ECRRepositoryName
          - Name: ECR_REPOSITORY_URI
            Value: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepositoryName}'
          - Name: PROJECT_NAME
            Value: !Ref ProjectName
          - Name: SNYK_TOKEN_SECRET
            Value: !If [HasSnykToken, !Ref SnykTokenSecret, '']
          - Name: PRISMA_CLOUD_SECRET
            Value: !If [HasPrismaCloudDetails, !Ref PrismaCloudSecret, '']
      Source:
        Type: NO_SOURCE
        BuildSpec: !Sub |
          version: 0.2
          
          phases:
            install:
              runtime-versions:
                python: 3.9
                nodejs: 14
              commands:
                - echo "Installing security scanning tools..."
                - pip install --upgrade pip
                - pip install boto3 requests
                
                # Install Snyk if token is provided
                - |
                  if [ ! -z "$SNYK_TOKEN_SECRET" ]; then
                    npm install -g snyk
                    SNYK_TOKEN=$(aws secretsmanager get-secret-value --secret-id $SNYK_TOKEN_SECRET --query SecretString --output text | jq -r '.token')
                    snyk auth $SNYK_TOKEN
                  fi
                
                # Install Prisma Cloud CLI if details are provided
                - |
                  if [ ! -z "$PRISMA_CLOUD_SECRET" ]; then
                    echo "Prisma Cloud integration configured"
                    # Note: Actual Prisma Cloud CLI installation would go here
                  fi
            
            pre_build:
              commands:
                - echo "Logging in to Amazon ECR..."
                - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REPOSITORY_URI
                - IMAGE_TAG=${!CODEBUILD_RESOLVED_SOURCE_VERSION:-latest}
                - echo "Build started on $(date)"
                
                # Create sample vulnerable application for testing
                - |
                  cat > Dockerfile << 'EOF'
                  FROM ubuntu:18.04
                  
                  # Install packages with known vulnerabilities for testing
                  RUN apt-get update && apt-get install -y \
                      curl \
                      wget \
                      openssl \
                      nodejs \
                      npm
                  
                  # Create application directory
                  WORKDIR /app
                  
                  # Copy application files
                  COPY package*.json ./
                  
                  # Install dependencies
                  RUN npm install
                  
                  # Copy source code
                  COPY . .
                  
                  # Expose port
                  EXPOSE 3000
                  
                  # Run application
                  CMD ["node", "app.js"]
                  EOF
                
                - |
                  cat > package.json << 'EOF'
                  {
                    "name": "security-test-app",
                    "version": "1.0.0",
                    "description": "Test application for security scanning",
                    "main": "app.js",
                    "dependencies": {
                      "express": "4.16.0",
                      "lodash": "4.17.4",
                      "request": "2.81.0"
                    }
                  }
                  EOF
                
                - |
                  cat > app.js << 'EOF'
                  const express = require('express');
                  const app = express();
                  const port = 3000;
                  
                  app.get('/', (req, res) => {
                      res.send('Hello from Security Test App!');
                  });
                  
                  app.listen(port, () => {
                      console.log(`App listening at http://localhost:${!port}`);
                  });
                  EOF
                
            build:
              commands:
                - echo "Building the Docker image..."
                - docker build -t $ECR_REPOSITORY_NAME:$IMAGE_TAG .
                - docker tag $ECR_REPOSITORY_NAME:$IMAGE_TAG $ECR_REPOSITORY_URI:$IMAGE_TAG
                
                # Run Snyk container security scan if available
                - |
                  if [ ! -z "$SNYK_TOKEN_SECRET" ]; then
                    echo "Running Snyk container scan..."
                    snyk container test $ECR_REPOSITORY_NAME:$IMAGE_TAG --severity-threshold=high --json > snyk-results.json || true
                    echo "Snyk scan completed"
                  fi
                
                # Run Prisma Cloud scan if available
                - |
                  if [ ! -z "$PRISMA_CLOUD_SECRET" ]; then
                    echo "Running Prisma Cloud scan..."
                    # Placeholder for Prisma Cloud scanning
                    echo '{"vulnerabilities": [], "compliance": {"passed": true}}' > prisma-results.json
                    echo "Prisma Cloud scan completed"
                  fi
                
            post_build:
              commands:
                - echo "Build completed on $(date)"
                - echo "Pushing the Docker image..."
                - docker push $ECR_REPOSITORY_URI:$IMAGE_TAG
                
                # Wait for enhanced scanning to complete
                - echo "Waiting for ECR enhanced scanning..."
                - sleep 30
                
                # Get ECR scan results
                - |
                  aws ecr describe-image-scan-findings \
                    --repository-name $ECR_REPOSITORY_NAME \
                    --image-id imageTag=$IMAGE_TAG \
                    > ecr-scan-results.json || true
                
                # Create consolidated scan results
                - |
                  python3 << 'EOF'
                  import json
                  import boto3
                  import os
                  from datetime import datetime
                  
                  # Initialize results
                  consolidated_results = {
                      'timestamp': datetime.utcnow().isoformat(),
                      'image_tag': os.environ.get('IMAGE_TAG', 'latest'),
                      'repository': os.environ.get('ECR_REPOSITORY_NAME', ''),
                      'scans': {}
                  }
                  
                  # Process ECR scan results
                  try:
                      with open('ecr-scan-results.json', 'r') as f:
                          ecr_data = json.load(f)
                          findings = ecr_data.get('imageScanFindings', {})
                          consolidated_results['scans']['ecr'] = {
                              'findings': findings.get('findings', []),
                              'counts': findings.get('findingCounts', {})
                          }
                  except FileNotFoundError:
                      consolidated_results['scans']['ecr'] = {'error': 'Scan results not found'}
                  
                  # Process Snyk results if available
                  try:
                      with open('snyk-results.json', 'r') as f:
                          snyk_data = json.load(f)
                          consolidated_results['scans']['snyk'] = snyk_data
                  except FileNotFoundError:
                      consolidated_results['scans']['snyk'] = {'status': 'not_configured'}
                  
                  # Process Prisma Cloud results if available
                  try:
                      with open('prisma-results.json', 'r') as f:
                          prisma_data = json.load(f)
                          consolidated_results['scans']['prisma'] = prisma_data
                  except FileNotFoundError:
                      consolidated_results['scans']['prisma'] = {'status': 'not_configured'}
                  
                  # Save consolidated results
                  with open('consolidated-scan-results.json', 'w') as f:
                      json.dump(consolidated_results, f, indent=2)
                  
                  print("Consolidated scan results created")
                  EOF
                
                - echo "Security scanning pipeline completed"
                
          artifacts:
            files:
              - '**/*'
      TimeoutInMinutes: 60
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-security-scanning'
        - Key: Project
          Value: !Ref ProjectName

  # ------------------------------------------------------------------------------
  # Lambda Function for Security Scan Processing
  # ------------------------------------------------------------------------------

  SecurityScanProcessorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-scan-processor'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 300
      MemorySize: 512
      Environment:
        Variables:
          SNS_TOPIC_ARN: !Ref SecurityAlertsTopic
          SLACK_TOPIC_ARN: !If [HasSlackWebhook, !Ref SlackNotificationTopic, '']
          FINDINGS_TABLE_NAME: !Ref SecurityFindingsTable
          PROJECT_NAME: !Ref ProjectName
          VULNERABILITY_THRESHOLDS: !Ref VulnerabilityThresholds
      Code:
        ZipFile: !Sub |
          import json
          import boto3
          import os
          from datetime import datetime
          import logging
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def lambda_handler(event, context):
              logger.info("Processing security scan results...")
              logger.info(f"Event: {json.dumps(event)}")
              
              try:
                  # Parse event from EventBridge
                  detail = event.get('detail', {})
                  source = event.get('source', '')
                  
                  if source == 'aws.inspector2':
                      # Handle Inspector2 (Enhanced Scanning) events
                      return process_inspector_event(detail)
                  elif source == 'aws.ecr':
                      # Handle ECR events
                      return process_ecr_event(detail)
                  else:
                      logger.warning(f"Unknown event source: {source}")
                      return {'statusCode': 200, 'body': 'Event processed'}
                      
              except Exception as e:
                  logger.error(f"Error processing event: {str(e)}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
          
          def process_inspector_event(detail):
              """Process Amazon Inspector2 enhanced scanning events"""
              logger.info("Processing Inspector2 event")
              
              # Extract scan details
              repository_name = detail.get('repository-name', '')
              image_digest = detail.get('image-digest', '')
              finding_counts = detail.get('finding-severity-counts', {})
              
              # Parse vulnerability thresholds
              thresholds = parse_vulnerability_thresholds()
              
              # Create consolidated security report
              security_report = {
                  'timestamp': datetime.utcnow().isoformat(),
                  'repository': repository_name,
                  'image_digest': image_digest,
                  'scan_type': 'enhanced',
                  'scan_results': {
                      'inspector2': finding_counts,
                      'total_vulnerabilities': finding_counts.get('TOTAL', 0),
                      'critical_vulnerabilities': finding_counts.get('CRITICAL', 0),
                      'high_vulnerabilities': finding_counts.get('HIGH', 0),
                      'medium_vulnerabilities': finding_counts.get('MEDIUM', 0),
                      'low_vulnerabilities': finding_counts.get('LOW', 0)
                  }
              }
              
              # Determine risk level and actions
              risk_assessment = assess_risk(finding_counts, thresholds)
              security_report['risk_assessment'] = risk_assessment
              
              # Store findings in DynamoDB
              store_security_findings(security_report)
              
              # Send to Security Hub
              send_to_security_hub(security_report)
              
              # Send notifications if required
              if risk_assessment['risk_level'] in ['CRITICAL', 'HIGH']:
                  send_notifications(security_report)
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(security_report)
              }
          
          def process_ecr_event(detail):
              """Process ECR scan completion events"""
              logger.info("Processing ECR event")
              
              # Extract scan details
              repository_name = detail.get('repository-name', '')
              image_tag = detail.get('image-tag', '')
              scan_status = detail.get('scan-status', '')
              
              if scan_status == 'COMPLETE':
                  # Get scan findings
                  ecr_client = boto3.client('ecr')
                  try:
                      response = ecr_client.describe_image_scan_findings(
                          repositoryName=repository_name,
                          imageId={'imageTag': image_tag}
                      )
                      
                      findings = response.get('imageScanFindings', {})
                      finding_counts = findings.get('findingCounts', {})
                      
                      # Create security report
                      security_report = {
                          'timestamp': datetime.utcnow().isoformat(),
                          'repository': repository_name,
                          'image_tag': image_tag,
                          'scan_type': 'basic',
                          'scan_results': {
                              'ecr_basic': finding_counts,
                              'findings': findings.get('findings', [])
                          }
                      }
                      
                      # Store findings
                      store_security_findings(security_report)
                      
                      return {
                          'statusCode': 200,
                          'body': json.dumps(security_report)
                      }
                      
                  except Exception as e:
                      logger.error(f"Error getting ECR scan findings: {str(e)}")
                      return {'statusCode': 500, 'body': f'Error: {str(e)}'}
              
              return {'statusCode': 200, 'body': 'Event processed'}
          
          def parse_vulnerability_thresholds():
              """Parse vulnerability thresholds from environment variable"""
              thresholds_str = os.environ.get('VULNERABILITY_THRESHOLDS', 'CRITICAL:0,HIGH:5,MEDIUM:10')
              thresholds = {}
              
              for threshold in thresholds_str.split(','):
                  if ':' in threshold:
                      severity, count = threshold.split(':')
                      thresholds[severity.strip()] = int(count.strip())
              
              return thresholds
          
          def assess_risk(finding_counts, thresholds):
              """Assess risk level based on vulnerability counts and thresholds"""
              critical_count = finding_counts.get('CRITICAL', 0)
              high_count = finding_counts.get('HIGH', 0)
              medium_count = finding_counts.get('MEDIUM', 0)
              
              # Determine risk level
              if critical_count > thresholds.get('CRITICAL', 0):
                  risk_level = 'CRITICAL'
                  action_required = 'IMMEDIATE_BLOCK'
              elif high_count > thresholds.get('HIGH', 5):
                  risk_level = 'HIGH'
                  action_required = 'REVIEW_REQUIRED'
              elif medium_count > thresholds.get('MEDIUM', 10):
                  risk_level = 'MEDIUM'
                  action_required = 'MONITOR'
              else:
                  risk_level = 'LOW'
                  action_required = 'APPROVED'
              
              return {
                  'risk_level': risk_level,
                  'action_required': action_required,
                  'compliance_status': 'FAIL' if critical_count > 0 else 'PASS',
                  'thresholds_exceeded': {
                      'critical': critical_count > thresholds.get('CRITICAL', 0),
                      'high': high_count > thresholds.get('HIGH', 5),
                      'medium': medium_count > thresholds.get('MEDIUM', 10)
                  }
              }
          
          def store_security_findings(security_report):
              """Store security findings in DynamoDB"""
              try:
                  dynamodb = boto3.resource('dynamodb')
                  table = dynamodb.Table(os.environ['FINDINGS_TABLE_NAME'])
                  
                  # Create item for DynamoDB
                  item = {
                      'id': f"{security_report['repository']}#{security_report['timestamp']}",
                      'repository': security_report['repository'],
                      'timestamp': security_report['timestamp'],
                      'scan_type': security_report.get('scan_type', 'unknown'),
                      'risk_level': security_report.get('risk_assessment', {}).get('risk_level', 'UNKNOWN'),
                      'scan_results': json.dumps(security_report['scan_results']),
                      'risk_assessment': json.dumps(security_report.get('risk_assessment', {}))
                  }
                  
                  table.put_item(Item=item)
                  logger.info("Security findings stored in DynamoDB")
                  
              except Exception as e:
                  logger.error(f"Error storing security findings: {str(e)}")
          
          def send_to_security_hub(security_report):
              """Send findings to AWS Security Hub"""
              try:
                  securityhub = boto3.client('securityhub')
                  
                  # Create Security Hub finding
                  finding = {
                      'SchemaVersion': '2018-10-08',
                      'Id': f"{security_report['repository']}-{security_report['timestamp']}",
                      'ProductArn': f"arn:aws:securityhub:${AWS::Region}:${AWS::AccountId}:product/custom/container-security-scanner",
                      'GeneratorId': 'container-security-pipeline',
                      'AwsAccountId': '${AWS::AccountId}',
                      'Title': f"Container Security Scan - {security_report['repository']}",
                      'Description': f"Security scan completed for {security_report['repository']}",
                      'CreatedAt': security_report['timestamp'],
                      'UpdatedAt': security_report['timestamp'],
                      'Severity': {
                          'Label': security_report.get('risk_assessment', {}).get('risk_level', 'INFORMATIONAL')
                      },
                      'Resources': [{
                          'Type': 'AwsEcrContainerImage',
                          'Id': f"{security_report['repository']}:{security_report.get('image_digest', security_report.get('image_tag', 'latest'))}",
                          'Region': '${AWS::Region}'
                      }],
                      'RecordState': 'ACTIVE',
                      'WorkflowState': 'NEW'
                  }
                  
                  securityhub.batch_import_findings(Findings=[finding])
                  logger.info("Finding sent to Security Hub")
                  
              except Exception as e:
                  logger.error(f"Error sending to Security Hub: {str(e)}")
          
          def send_notifications(security_report):
              """Send notifications based on risk level"""
              try:
                  sns = boto3.client('sns')
                  
                  # Prepare notification message
                  message = {
                      'alert_type': 'Container Security Alert',
                      'risk_level': security_report['risk_assessment']['risk_level'],
                      'repository': security_report['repository'],
                      'timestamp': security_report['timestamp'],
                      'action_required': security_report['risk_assessment']['action_required'],
                      'summary': security_report['scan_results']
                  }
                  
                  # Send to main SNS topic
                  sns.publish(
                      TopicArn=os.environ['SNS_TOPIC_ARN'],
                      Message=json.dumps(message, indent=2),
                      Subject=f"Container Security Alert - {security_report['risk_assessment']['risk_level']} Risk Detected"
                  )
                  
                  # Send to Slack topic if configured
                  slack_topic = os.environ.get('SLACK_TOPIC_ARN')
                  if slack_topic:
                      sns.publish(
                          TopicArn=slack_topic,
                          Message=json.dumps(message, indent=2),
                          Subject=f"Container Security Alert - {security_report['risk_assessment']['risk_level']} Risk"
                      )
                  
                  logger.info("Notifications sent successfully")
                  
              except Exception as e:
                  logger.error(f"Error sending notifications: {str(e)}")
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-scan-processor'
        - Key: Project
          Value: !Ref ProjectName

  # CloudWatch Log Group for Lambda
  SecurityScanProcessorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${ProjectName}-scan-processor'
      RetentionInDays: !Ref RetentionInDays

  # ------------------------------------------------------------------------------
  # DynamoDB Table for Security Findings
  # ------------------------------------------------------------------------------

  SecurityFindingsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${ProjectName}-security-findings'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
        - AttributeName: repository
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: S
        - AttributeName: risk_level
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: repository-timestamp-index
          KeySchema:
            - AttributeName: repository
              KeyType: HASH
            - AttributeName: timestamp
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        - IndexName: risk-level-index
          KeySchema:
            - AttributeName: risk_level
              KeyType: HASH
            - AttributeName: timestamp
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-security-findings'
        - Key: Project
          Value: !Ref ProjectName

  # ------------------------------------------------------------------------------
  # SNS Topics for Notifications
  # ------------------------------------------------------------------------------

  SecurityAlertsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub '${ProjectName}-security-alerts'
      DisplayName: 'Container Security Alerts'
      KmsMasterKeyId: alias/aws/sns
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-security-alerts'
        - Key: Project
          Value: !Ref ProjectName

  SecurityAlertsSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Protocol: email
      TopicArn: !Ref SecurityAlertsTopic
      Endpoint: !Ref NotificationEmail

  SlackNotificationTopic:
    Type: AWS::SNS::Topic
    Condition: HasSlackWebhook
    Properties:
      TopicName: !Sub '${ProjectName}-slack-notifications'
      DisplayName: 'Slack Container Security Notifications'
      KmsMasterKeyId: alias/aws/sns
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-slack-notifications'
        - Key: Project
          Value: !Ref ProjectName

  SlackNotificationFunction:
    Type: AWS::Lambda::Function
    Condition: HasSlackWebhook
    Properties:
      FunctionName: !Sub '${ProjectName}-slack-notifier'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt SlackNotificationRole.Arn
      Timeout: 30
      Environment:
        Variables:
          SLACK_WEBHOOK_URL: !Ref SlackWebhookUrl
      Code:
        ZipFile: !Sub |
          import json
          import urllib3
          import os
          
          def lambda_handler(event, context):
              webhook_url = os.environ['SLACK_WEBHOOK_URL']
              
              # Parse SNS message
              for record in event['Records']:
                  sns_message = json.loads(record['Sns']['Message'])
                  
                  # Create Slack message
                  slack_message = {
                      'text': f"ðŸš¨ Container Security Alert",
                      'attachments': [{
                          'color': 'danger' if sns_message['risk_level'] in ['CRITICAL', 'HIGH'] else 'warning',
                          'fields': [
                              {
                                  'title': 'Repository',
                                  'value': sns_message['repository'],
                                  'short': True
                              },
                              {
                                  'title': 'Risk Level',
                                  'value': sns_message['risk_level'],
                                  'short': True
                              },
                              {
                                  'title': 'Action Required',
                                  'value': sns_message['action_required'],
                                  'short': True
                              },
                              {
                                  'title': 'Timestamp',
                                  'value': sns_message['timestamp'],
                                  'short': True
                              }
                          ]
                      }]
                  }
                  
                  # Send to Slack
                  http = urllib3.PoolManager()
                  response = http.request(
                      'POST',
                      webhook_url,
                      body=json.dumps(slack_message),
                      headers={'Content-Type': 'application/json'}
                  )
                  
                  print(f"Slack notification sent: {response.status}")
              
              return {'statusCode': 200, 'body': 'Notifications sent'}
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-slack-notifier'
        - Key: Project
          Value: !Ref ProjectName

  SlackNotificationRole:
    Type: AWS::IAM::Role
    Condition: HasSlackWebhook
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-slack-notification-role'
        - Key: Project
          Value: !Ref ProjectName

  SlackNotificationSubscription:
    Type: AWS::SNS::Subscription
    Condition: HasSlackWebhook
    Properties:
      Protocol: lambda
      TopicArn: !Ref SlackNotificationTopic
      Endpoint: !GetAtt SlackNotificationFunction.Arn

  SlackNotificationPermission:
    Type: AWS::Lambda::Permission
    Condition: HasSlackWebhook
    Properties:
      FunctionName: !Ref SlackNotificationFunction
      Action: lambda:InvokeFunction
      Principal: sns.amazonaws.com
      SourceArn: !Ref SlackNotificationTopic

  # ------------------------------------------------------------------------------
  # EventBridge Rules for Security Scanning Events
  # ------------------------------------------------------------------------------

  # EventBridge Rule for Inspector2 Enhanced Scanning
  InspectorScanCompletedRule:
    Type: AWS::Events::Rule
    Condition: EnableEnhancedScanningCondition
    Properties:
      Name: !Sub '${ProjectName}-inspector-scan-completed'
      Description: 'Trigger processing when Inspector2 enhanced scanning completes'
      EventPattern:
        source:
          - aws.inspector2
        detail-type:
          - Inspector2 Scan
        detail:
          scan-status:
            - INITIAL_SCAN_COMPLETE
            - SCAN_COMPLETE
      State: ENABLED
      Targets:
        - Arn: !GetAtt SecurityScanProcessorFunction.Arn
          Id: SecurityScanProcessorTarget
          RoleArn: !GetAtt EventBridgeExecutionRole.Arn

  # EventBridge Rule for ECR Basic Scanning
  ECRScanCompletedRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${ProjectName}-ecr-scan-completed'
      Description: 'Trigger processing when ECR basic scanning completes'
      EventPattern:
        source:
          - aws.ecr
        detail-type:
          - ECR Image Scan
        detail:
          scan-status:
            - COMPLETE
          repository-name:
            - !Ref ECRRepositoryName
      State: ENABLED
      Targets:
        - Arn: !GetAtt SecurityScanProcessorFunction.Arn
          Id: SecurityScanProcessorTarget
          RoleArn: !GetAtt EventBridgeExecutionRole.Arn

  # Lambda permissions for EventBridge
  InspectorScanProcessorPermission:
    Type: AWS::Lambda::Permission
    Condition: EnableEnhancedScanningCondition
    Properties:
      FunctionName: !Ref SecurityScanProcessorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt InspectorScanCompletedRule.Arn

  ECRScanProcessorPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SecurityScanProcessorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt ECRScanCompletedRule.Arn

  # ------------------------------------------------------------------------------
  # AWS Config Rules for Compliance
  # ------------------------------------------------------------------------------

  ConfigConfigurationRecorder:
    Type: AWS::Config::ConfigurationRecorder
    Properties:
      Name: !Sub '${ProjectName}-config-recorder'
      RoleArn: !GetAtt ConfigRole.Arn
      RecordingGroup:
        AllSupported: false
        ResourceTypes:
          - AWS::ECR::Repository

  ConfigDeliveryChannel:
    Type: AWS::Config::DeliveryChannel
    Properties:
      Name: !Sub '${ProjectName}-delivery-channel'
      S3BucketName: !Ref ConfigBucket

  ConfigRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: config.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/ConfigRole
      Policies:
        - PolicyName: ConfigS3Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetBucketAcl
                  - s3:GetBucketLocation
                  - s3:PutObject
                  - s3:GetObject
                Resource:
                  - !Sub '${ConfigBucket}/*'
                  - !GetAtt ConfigBucket.Arn
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-config-role'
        - Key: Project
          Value: !Ref ProjectName

  ConfigBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${ProjectName}-config-${AWS::AccountId}-${AWS::Region}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldVersions
            Status: Enabled
            NoncurrentVersionExpirationInDays: 30
          - Id: DeleteIncompleteMultipartUploads
            Status: Enabled
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 7
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-config-bucket'
        - Key: Project
          Value: !Ref ProjectName

  # Config Rule for ECR Repository Scanning
  ECRRepositoryScanEnabledRule:
    Type: AWS::Config::ConfigRule
    DependsOn: ConfigConfigurationRecorder
    Properties:
      ConfigRuleName: !Sub '${ProjectName}-ecr-repository-scan-enabled'
      Description: 'Checks whether ECR repositories have image scanning enabled'
      Source:
        Owner: AWS
        SourceIdentifier: ECR_PRIVATE_IMAGE_SCANNING_ENABLED
      Scope:
        ComplianceResourceTypes:
          - AWS::ECR::Repository

  # ------------------------------------------------------------------------------
  # CloudWatch Dashboard for Security Metrics
  # ------------------------------------------------------------------------------

  SecurityDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: !Sub '${ProjectName}-security-dashboard'
      DashboardBody: !Sub |
        {
          "widgets": [
            {
              "type": "metric",
              "x": 0,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "AWS/ECR", "RepositoryCount" ],
                  [ "AWS/ECR", "ImageCount" ]
                ],
                "period": 300,
                "stat": "Sum",
                "region": "${AWS::Region}",
                "title": "ECR Repository Metrics"
              }
            },
            {
              "type": "log",
              "x": 0,
              "y": 6,
              "width": 24,
              "height": 6,
              "properties": {
                "query": "SOURCE '/aws/lambda/${ProjectName}-scan-processor' | fields @timestamp, @message | filter @message like /CRITICAL/ | sort @timestamp desc | limit 20",
                "region": "${AWS::Region}",
                "title": "Critical Security Findings"
              }
            },
            {
              "type": "metric",
              "x": 12,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "AWS/Lambda", "Invocations", "FunctionName", "${ProjectName}-scan-processor" ],
                  [ "AWS/Lambda", "Errors", "FunctionName", "${ProjectName}-scan-processor" ],
                  [ "AWS/Lambda", "Duration", "FunctionName", "${ProjectName}-scan-processor" ]
                ],
                "period": 300,
                "stat": "Sum",
                "region": "${AWS::Region}",
                "title": "Lambda Function Metrics"
              }
            }
          ]
        }

# ==============================================================================
# OUTPUTS
# ==============================================================================

Outputs:
  ECRRepositoryURI:
    Description: 'URI of the ECR repository'
    Value: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepositoryName}'
    Export:
      Name: !Sub '${ProjectName}-ECRRepositoryURI'

  ECRRepositoryName:
    Description: 'Name of the ECR repository'
    Value: !Ref ECRRepositoryName
    Export:
      Name: !Sub '${ProjectName}-ECRRepositoryName'

  SecurityScanningProjectName:
    Description: 'Name of the CodeBuild project for security scanning'
    Value: !Ref SecurityScanningProject
    Export:
      Name: !Sub '${ProjectName}-SecurityScanningProject'

  SecurityScanProcessorFunctionName:
    Description: 'Name of the Lambda function for processing scan results'
    Value: !Ref SecurityScanProcessorFunction
    Export:
      Name: !Sub '${ProjectName}-SecurityScanProcessorFunction'

  SecurityAlertsTopicArn:
    Description: 'ARN of the SNS topic for security alerts'
    Value: !Ref SecurityAlertsTopic
    Export:
      Name: !Sub '${ProjectName}-SecurityAlertsTopic'

  SecurityFindingsTableName:
    Description: 'Name of the DynamoDB table storing security findings'
    Value: !Ref SecurityFindingsTable
    Export:
      Name: !Sub '${ProjectName}-SecurityFindingsTable'

  SecurityDashboardURL:
    Description: 'URL of the CloudWatch dashboard for security metrics'
    Value: !Sub 'https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${ProjectName}-security-dashboard'
    Export:
      Name: !Sub '${ProjectName}-SecurityDashboardURL'

  EnhancedScanningEnabled:
    Description: 'Whether enhanced scanning is enabled'
    Value: !Ref EnableEnhancedScanning
    Export:
      Name: !Sub '${ProjectName}-EnhancedScanningEnabled'

  ConfigRuleName:
    Description: 'Name of the Config rule for ECR repository compliance'
    Value: !Ref ECRRepositoryScanEnabledRule
    Export:
      Name: !Sub '${ProjectName}-ConfigRuleName'

  SlackNotificationTopicArn:
    Condition: HasSlackWebhook
    Description: 'ARN of the SNS topic for Slack notifications'
    Value: !Ref SlackNotificationTopic
    Export:
      Name: !Sub '${ProjectName}-SlackNotificationTopic'

  ProjectName:
    Description: 'Project name used as prefix for all resources'
    Value: !Ref ProjectName
    Export:
      Name: !Sub '${ProjectName}-ProjectName'

  DeploymentInstructions:
    Description: 'Instructions for using this security scanning pipeline'
    Value: !Sub |
      1. Push container images to ECR repository: ${ECRRepositoryURI}
      2. Enhanced scanning will automatically trigger on push (if enabled)
      3. Monitor security findings in CloudWatch dashboard: https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${ProjectName}-security-dashboard
      4. Check SNS topics for security alerts: ${SecurityAlertsTopic}
      5. View detailed findings in DynamoDB table: ${SecurityFindingsTable}
      6. Run CodeBuild project manually: ${SecurityScanningProject}