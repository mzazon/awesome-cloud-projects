AWSTemplateFormatVersion: '2010-09-09'
Description: >
  Knowledge Management Assistant with Amazon Bedrock Agents
  This template creates a complete knowledge management solution using Amazon Bedrock Agents,
  Knowledge Bases, S3 document storage, Lambda functions, and API Gateway for enterprise
  document querying with natural language processing capabilities.

# Template Metadata
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Knowledge Base Configuration"
        Parameters:
          - KnowledgeBaseName
          - EmbeddingModel
          - ChunkingStrategy
          - MaxTokensPerChunk
          - OverlapPercentage
      - Label:
          default: "Bedrock Agent Configuration"
        Parameters:
          - AgentName
          - FoundationModel
          - AgentInstructions
          - SessionTimeoutMinutes
      - Label:
          default: "Storage and Infrastructure"
        Parameters:
          - DocumentBucketName
          - CollectionName
          - EnableVersioning
          - EnableEncryption
      - Label:
          default: "API and Lambda Configuration"
        Parameters:
          - ApiName
          - LambdaFunctionName
          - LambdaMemorySize
          - LambdaTimeoutSeconds
          - EnableCorsSupport
      - Label:
          default: "Security and Monitoring"
        Parameters:
          - EnableApiLogging
          - EnableDetailedMonitoring
          - LogRetentionDays
    ParameterLabels:
      KnowledgeBaseName:
        default: "Knowledge Base Name"
      AgentName:
        default: "Bedrock Agent Name"
      DocumentBucketName:
        default: "Document Storage Bucket Name"

# Input Parameters with comprehensive validation
Parameters:
  # Knowledge Base Configuration
  KnowledgeBaseName:
    Type: String
    Default: "enterprise-knowledge-base"
    Description: "Name for the Bedrock Knowledge Base"
    MinLength: 1
    MaxLength: 64
    AllowedPattern: "^[a-zA-Z0-9-_]+$"
    ConstraintDescription: "Must contain only alphanumeric characters, hyphens, and underscores"

  EmbeddingModel:
    Type: String
    Default: "amazon.titan-embed-text-v2:0"
    Description: "Embedding model for document processing"
    AllowedValues:
      - "amazon.titan-embed-text-v1"
      - "amazon.titan-embed-text-v2:0"
      - "cohere.embed-english-v3"
      - "cohere.embed-multilingual-v3"

  ChunkingStrategy:
    Type: String
    Default: "FIXED_SIZE"
    Description: "Strategy for chunking documents"
    AllowedValues:
      - "FIXED_SIZE"
      - "NONE"

  MaxTokensPerChunk:
    Type: Number
    Default: 300
    MinValue: 50
    MaxValue: 8192
    Description: "Maximum tokens per document chunk"

  OverlapPercentage:
    Type: Number
    Default: 20
    MinValue: 0
    MaxValue: 99
    Description: "Percentage overlap between document chunks"

  # Bedrock Agent Configuration
  AgentName:
    Type: String
    Default: "knowledge-assistant"
    Description: "Name for the Bedrock Agent"
    MinLength: 1
    MaxLength: 64
    AllowedPattern: "^[a-zA-Z0-9-_]+$"
    ConstraintDescription: "Must contain only alphanumeric characters, hyphens, and underscores"

  FoundationModel:
    Type: String
    Default: "anthropic.claude-3-5-sonnet-20241022-v2:0"
    Description: "Foundation model for the Bedrock Agent"
    AllowedValues:
      - "anthropic.claude-3-5-sonnet-20241022-v2:0"
      - "anthropic.claude-3-haiku-20240307-v1:0"
      - "anthropic.claude-3-sonnet-20240229-v1:0"
      - "amazon.titan-text-premier-v1:0"

  AgentInstructions:
    Type: String
    Default: |
      You are a helpful enterprise knowledge management assistant powered by Amazon Bedrock. 
      Your role is to help employees find accurate information from company documents, policies, 
      and procedures. Always provide specific, actionable answers and cite sources when possible. 
      If you cannot find relevant information in the knowledge base, clearly state that and suggest 
      alternative resources or contacts. Maintain a professional tone while being conversational 
      and helpful. When providing policy information, always mention if employees should verify 
      with HR for the most current version.
    Description: "Instructions for the Bedrock Agent behavior"
    MaxLength: 4000

  SessionTimeoutMinutes:
    Type: Number
    Default: 30
    MinValue: 5
    MaxValue: 120
    Description: "Session timeout in minutes for agent conversations"

  # Storage and Infrastructure
  DocumentBucketName:
    Type: String
    Default: ""
    Description: "S3 bucket name for document storage (leave empty for auto-generated)"
    AllowedPattern: "^$|^[a-z0-9][a-z0-9-]*[a-z0-9]$"
    ConstraintDescription: "Must be a valid S3 bucket name or empty for auto-generation"

  CollectionName:
    Type: String
    Default: "kb-collection"
    Description: "OpenSearch Serverless collection name"
    MinLength: 1
    MaxLength: 32
    AllowedPattern: "^[a-z][a-z0-9-]*$"
    ConstraintDescription: "Must start with lowercase letter and contain only lowercase letters, numbers, and hyphens"

  EnableVersioning:
    Type: String
    Default: "true"
    AllowedValues: ["true", "false"]
    Description: "Enable S3 bucket versioning"

  EnableEncryption:
    Type: String
    Default: "true"
    AllowedValues: ["true", "false"]
    Description: "Enable S3 bucket encryption"

  # API and Lambda Configuration
  ApiName:
    Type: String
    Default: "knowledge-management-api"
    Description: "Name for the API Gateway"
    MinLength: 1
    MaxLength: 64

  LambdaFunctionName:
    Type: String
    Default: "bedrock-agent-proxy"
    Description: "Name for the Lambda function"
    MinLength: 1
    MaxLength: 64
    AllowedPattern: "^[a-zA-Z0-9-_]+$"

  LambdaMemorySize:
    Type: Number
    Default: 256
    AllowedValues: [128, 256, 512, 1024, 2048, 3008]
    Description: "Memory size for Lambda function in MB"

  LambdaTimeoutSeconds:
    Type: Number
    Default: 30
    MinValue: 3
    MaxValue: 900
    Description: "Timeout for Lambda function in seconds"

  EnableCorsSupport:
    Type: String
    Default: "true"
    AllowedValues: ["true", "false"]
    Description: "Enable CORS support for API Gateway"

  # Security and Monitoring
  EnableApiLogging:
    Type: String
    Default: "true"
    AllowedValues: ["true", "false"]
    Description: "Enable API Gateway access logging"

  EnableDetailedMonitoring:
    Type: String
    Default: "true"
    AllowedValues: ["true", "false"]
    Description: "Enable detailed CloudWatch monitoring"

  LogRetentionDays:
    Type: Number
    Default: 30
    AllowedValues: [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]
    Description: "CloudWatch log retention period in days"

# Conditions for conditional resource creation
Conditions:
  CreateBucketName: !Equals [!Ref DocumentBucketName, ""]
  EnableS3Versioning: !Equals [!Ref EnableVersioning, "true"]
  EnableS3Encryption: !Equals [!Ref EnableEncryption, "true"]
  EnableCors: !Equals [!Ref EnableCorsSupport, "true"]
  EnableLogging: !Equals [!Ref EnableApiLogging, "true"]
  EnableMonitoring: !Equals [!Ref EnableDetailedMonitoring, "true"]
  UseFixedSizeChunking: !Equals [!Ref ChunkingStrategy, "FIXED_SIZE"]

# AWS Resources
Resources:
  # S3 Bucket for Document Storage with comprehensive security configuration
  DocumentBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !If
        - CreateBucketName
        - !Sub "${AWS::StackName}-documents-${AWS::AccountId}"
        - !Ref DocumentBucketName
      BucketEncryption: !If
        - EnableS3Encryption
        - ServerSideEncryptionConfiguration:
            - ServerSideEncryptionByDefault:
                SSEAlgorithm: AES256
              BucketKeyEnabled: true
        - !Ref AWS::NoValue
      VersioningConfiguration: !If
        - EnableS3Versioning
        - Status: Enabled
        - !Ref AWS::NoValue
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      NotificationConfiguration:
        CloudWatchConfigurations:
          - Event: "s3:ObjectCreated:*"
            CloudWatchConfiguration:
              LogGroupName: !Ref S3AccessLogGroup
      LoggingConfiguration:
        DestinationBucketName: !Ref S3AccessLogBucket
        LogFilePrefix: "access-logs/"
      LifecycleConfiguration:
        Rules:
          - Id: "DocumentRetentionRule"
            Status: Enabled
            Transitions:
              - TransitionInDays: 30
                StorageClass: STANDARD_IA
              - TransitionInDays: 90
                StorageClass: GLACIER
              - TransitionInDays: 365
                StorageClass: DEEP_ARCHIVE
      Tags:
        - Key: "Purpose"
          Value: "Knowledge Management Documents"
        - Key: "Environment"
          Value: !Ref AWS::StackName

  # S3 Bucket for Access Logs
  S3AccessLogBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-access-logs-${AWS::AccountId}"
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: "LogRetentionRule"
            Status: Enabled
            ExpirationInDays: !Ref LogRetentionDays

  # CloudWatch Log Group for S3 Access Logs
  S3AccessLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/s3/${AWS::StackName}-access-logs"
      RetentionInDays: !Ref LogRetentionDays

  # OpenSearch Serverless Security Policy
  OpenSearchSecurityPolicy:
    Type: AWS::OpenSearchServerless::SecurityPolicy
    Properties:
      Name: !Sub "${AWS::StackName}-security-policy"
      Type: encryption
      Policy: !Sub |
        {
          "Rules": [
            {
              "ResourceType": "collection",
              "Resource": ["collection/${CollectionName}-*"]
            }
          ],
          "AWSOwnedKey": true
        }

  # OpenSearch Serverless Network Policy
  OpenSearchNetworkPolicy:
    Type: AWS::OpenSearchServerless::SecurityPolicy
    Properties:
      Name: !Sub "${AWS::StackName}-network-policy"
      Type: network
      Policy: !Sub |
        [
          {
            "Rules": [
              {
                "ResourceType": "collection",
                "Resource": ["collection/${CollectionName}-*"]
              },
              {
                "ResourceType": "dashboard",
                "Resource": ["collection/${CollectionName}-*"]
              }
            ],
            "AllowFromPublic": true
          }
        ]

  # OpenSearch Serverless Data Access Policy
  OpenSearchDataAccessPolicy:
    Type: AWS::OpenSearchServerless::AccessPolicy
    Properties:
      Name: !Sub "${AWS::StackName}-data-access-policy"
      Type: data
      Policy: !Sub |
        [
          {
            "Rules": [
              {
                "ResourceType": "collection",
                "Resource": ["collection/${CollectionName}-*"],
                "Permission": [
                  "aoss:CreateCollectionItems",
                  "aoss:DeleteCollectionItems",
                  "aoss:UpdateCollectionItems",
                  "aoss:DescribeCollectionItems"
                ]
              },
              {
                "ResourceType": "index",
                "Resource": ["index/${CollectionName}-*/knowledge-index"],
                "Permission": [
                  "aoss:CreateIndex",
                  "aoss:DeleteIndex",
                  "aoss:UpdateIndex",
                  "aoss:DescribeIndex",
                  "aoss:ReadDocument",
                  "aoss:WriteDocument"
                ]
              }
            ],
            "Principal": [
              "${BedrockServiceRole.Arn}"
            ]
          }
        ]

  # OpenSearch Serverless Collection for Vector Search
  OpenSearchCollection:
    Type: AWS::OpenSearchServerless::Collection
    DependsOn:
      - OpenSearchSecurityPolicy
      - OpenSearchNetworkPolicy
    Properties:
      Name: !Sub "${CollectionName}-${AWS::AccountId}"
      Type: VECTORSEARCH
      Description: "Vector collection for Bedrock Knowledge Base document search"
      Tags:
        - Key: "Purpose"
          Value: "Bedrock Knowledge Base Vector Storage"
        - Key: "Environment"
          Value: !Ref AWS::StackName

  # IAM Role for Bedrock Agent with comprehensive permissions
  BedrockServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-bedrock-agent-role"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                "aws:SourceAccount": !Ref AWS::AccountId
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
      Policies:
        - PolicyName: S3DocumentAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:GetObjectVersion
                  - s3:ListBucket
                  - s3:ListBucketVersions
                Resource:
                  - !Sub "${DocumentBucket}/*"
                  - !GetAtt DocumentBucket.Arn
              - Effect: Allow
                Action:
                  - s3:ListAllMyBuckets
                Resource: "*"
        - PolicyName: OpenSearchAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - aoss:APIAccessAll
                  - aoss:CreateCollectionItems
                  - aoss:DeleteCollectionItems
                  - aoss:UpdateCollectionItems
                  - aoss:DescribeCollectionItems
                Resource: !Sub "arn:aws:aoss:${AWS::Region}:${AWS::AccountId}:collection/*"
        - PolicyName: BedrockModelAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                  - bedrock:Retrieve
                  - bedrock:RetrieveAndGenerate
                Resource:
                  - !Sub "arn:aws:bedrock:${AWS::Region}::foundation-model/*"
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*"
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock/*"
      Tags:
        - Key: "Purpose"
          Value: "Bedrock Agent Service Role"

  # CloudWatch Log Group for Bedrock Agent
  BedrockLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/bedrock/agent/${AgentName}"
      RetentionInDays: !Ref LogRetentionDays

  # Bedrock Knowledge Base
  KnowledgeBase:
    Type: AWS::Bedrock::KnowledgeBase
    DependsOn:
      - OpenSearchCollection
      - OpenSearchDataAccessPolicy
    Properties:
      Name: !Sub "${KnowledgeBaseName}-${AWS::AccountId}"
      Description: "Enterprise knowledge base for company policies and procedures"
      RoleArn: !GetAtt BedrockServiceRole.Arn
      KnowledgeBaseConfiguration:
        Type: VECTOR
        VectorKnowledgeBaseConfiguration:
          EmbeddingModelArn: !Sub "arn:aws:bedrock:${AWS::Region}::foundation-model/${EmbeddingModel}"
          EmbeddingModelConfiguration:
            BedrockEmbeddingModelConfiguration:
              Dimensions: 1024
      StorageConfiguration:
        Type: OPENSEARCH_SERVERLESS
        OpensearchServerlessConfiguration:
          CollectionArn: !GetAtt OpenSearchCollection.Arn
          VectorIndexName: "knowledge-index"
          FieldMapping:
            VectorField: "vector"
            TextField: "text"
            MetadataField: "metadata"
      Tags:
        Purpose: "Enterprise Knowledge Management"
        Environment: !Ref AWS::StackName

  # Bedrock Knowledge Base Data Source
  KnowledgeBaseDataSource:
    Type: AWS::Bedrock::DataSource
    Properties:
      KnowledgeBaseId: !Ref KnowledgeBase
      Name: "s3-document-source"
      Description: "S3 data source for enterprise documents"
      DataSourceConfiguration:
        Type: S3
        S3Configuration:
          BucketArn: !GetAtt DocumentBucket.Arn
          InclusionPrefixes:
            - "documents/"
      VectorIngestionConfiguration: !If
        - UseFixedSizeChunking
        - ChunkingConfiguration:
            ChunkingStrategy: FIXED_SIZE
            FixedSizeChunkingConfiguration:
              MaxTokens: !Ref MaxTokensPerChunk
              OverlapPercentage: !Ref OverlapPercentage
        - ChunkingConfiguration:
            ChunkingStrategy: NONE

  # Bedrock Agent
  BedrockAgent:
    Type: AWS::Bedrock::Agent
    Properties:
      AgentName: !Sub "${AgentName}-${AWS::AccountId}"
      Description: "Enterprise knowledge management assistant powered by Claude"
      Instruction: !Ref AgentInstructions
      FoundationModel: !Ref FoundationModel
      AgentResourceRoleArn: !GetAtt BedrockServiceRole.Arn
      IdleSessionTTLInSeconds: !Ref SessionTimeoutMinutes
      AutoPrepare: true
      KnowledgeBases:
        - KnowledgeBaseId: !Ref KnowledgeBase
          Description: "Enterprise knowledge base association"
          KnowledgeBaseState: ENABLED
      Tags:
        Purpose: "Knowledge Management Assistant"
        Environment: !Ref AWS::StackName

  # IAM Role for Lambda Function with minimal required permissions
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-lambda-execution-role"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BedrockAgentInvoke
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeAgent
                Resource: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*"
        - PolicyName: CloudWatchMetrics
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: "*"
                Condition:
                  StringEquals:
                    "cloudwatch:namespace": "AWS/Lambda"

  # CloudWatch Log Group for Lambda
  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${LambdaFunctionName}"
      RetentionInDays: !Ref LogRetentionDays

  # Lambda Function for API Gateway Integration
  LambdaFunction:
    Type: AWS::Lambda::Function
    DependsOn: LambdaLogGroup
    Properties:
      FunctionName: !Sub "${LambdaFunctionName}-${AWS::AccountId}"
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      MemorySize: !Ref LambdaMemorySize
      Timeout: !Ref LambdaTimeoutSeconds
      Environment:
        Variables:
          AGENT_ID: !GetAtt BedrockAgent.AgentId
          LOG_LEVEL: "INFO"
      ReservedConcurrencyExecutions: 100
      DeadLetterQueue:
        TargetArn: !GetAtt DeadLetterQueue.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging
          from botocore.exceptions import ClientError
          
          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(os.environ.get('LOG_LEVEL', 'INFO'))
          
          def lambda_handler(event, context):
              """
              Enhanced Lambda handler for Bedrock Agent integration
              with improved error handling and logging
              """
              # Initialize Bedrock Agent Runtime client
              bedrock_agent = boto3.client('bedrock-agent-runtime')
              
              try:
                  # Parse request body with enhanced validation
                  if 'body' in event:
                      body = json.loads(event['body']) if isinstance(event['body'], str) else event['body']
                  else:
                      body = event
                  
                  query = body.get('query', '').strip()
                  session_id = body.get('sessionId', 'default-session')
                  
                  # Validate input
                  if not query:
                      logger.warning("Empty query received")
                      return {
                          'statusCode': 400,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Headers': 'Content-Type',
                              'Access-Control-Allow-Methods': 'POST, OPTIONS'
                          },
                          'body': json.dumps({
                              'error': 'Query parameter is required and cannot be empty'
                          })
                      }
                  
                  if len(query) > 1000:
                      logger.warning(f"Query too long: {len(query)} characters")
                      return {
                          'statusCode': 400,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*'
                          },
                          'body': json.dumps({
                              'error': 'Query too long. Please limit to 1000 characters.'
                          })
                      }
                  
                  logger.info(f"Processing query for session: {session_id}")
                  
                  # Invoke Bedrock Agent with enhanced configuration
                  response = bedrock_agent.invoke_agent(
                      agentId=os.environ['AGENT_ID'],
                      agentAliasId='TSTALIASID',
                      sessionId=session_id,
                      inputText=query,
                      enableTrace=True
                  )
                  
                  # Process response stream with better error handling
                  response_text = ""
                  trace_info = []
                  
                  for chunk in response['completion']:
                      if 'chunk' in chunk:
                          chunk_data = chunk['chunk']
                          if 'bytes' in chunk_data:
                              response_text += chunk_data['bytes'].decode('utf-8')
                      elif 'trace' in chunk:
                          trace_info.append(chunk['trace'])
                  
                  logger.info(f"Successfully processed query, response length: {len(response_text)}")
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type',
                          'Access-Control-Allow-Methods': 'POST, OPTIONS'
                      },
                      'body': json.dumps({
                          'response': response_text,
                          'sessionId': session_id,
                          'timestamp': context.aws_request_id
                      })
                  }
                  
              except ClientError as e:
                  error_code = e.response['Error']['Code']
                  logger.error(f"AWS service error: {error_code} - {str(e)}")
                  
                  return {
                      'statusCode': 503 if error_code in ['ThrottlingException', 'ServiceQuotaExceededException'] else 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({
                          'error': f'Service temporarily unavailable. Please try again later.',
                          'requestId': context.aws_request_id
                      })
                  }
                  
              except json.JSONDecodeError as e:
                  logger.error(f"JSON decode error: {str(e)}")
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({
                          'error': 'Invalid JSON format in request body'
                      })
                  }
                  
              except Exception as e:
                  logger.error(f"Unexpected error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({
                          'error': 'Internal server error',
                          'requestId': context.aws_request_id
                      })
                  }
      Tags:
        - Key: "Purpose"
          Value: "Bedrock Agent API Proxy"
        - Key: "Environment"
          Value: !Ref AWS::StackName

  # SQS Dead Letter Queue for Lambda
  DeadLetterQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub "${AWS::StackName}-dlq"
      MessageRetentionPeriod: 1209600  # 14 days
      VisibilityTimeoutSeconds: 300
      Tags:
        - Key: "Purpose"
          Value: "Lambda Dead Letter Queue"

  # CloudWatch Alarm for Lambda Errors
  LambdaErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: EnableMonitoring
    Properties:
      AlarmName: !Sub "${AWS::StackName}-lambda-errors"
      AlarmDescription: "Lambda function error rate alarm"
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 2
      Threshold: 5
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref LambdaFunction
      TreatMissingData: notBreaching

  # API Gateway REST API
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "${ApiName}-${AWS::AccountId}"
      Description: "Knowledge Management Assistant API"
      EndpointConfiguration:
        Types:
          - REGIONAL
      Policy:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: '*'
            Action: 'execute-api:Invoke'
            Resource: '*'
      Tags:
        - Key: "Purpose"
          Value: "Knowledge Management API"

  # API Gateway Resource for /query endpoint
  QueryResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: query

  # API Gateway OPTIONS Method for CORS
  QueryOptionsMethod:
    Type: AWS::ApiGateway::Method
    Condition: EnableCors
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref QueryResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: false
            method.response.header.Access-Control-Allow-Methods: false
            method.response.header.Access-Control-Allow-Origin: false

  # API Gateway POST Method
  QueryPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref QueryResource
      HttpMethod: POST
      AuthorizationType: NONE
      RequestValidatorId: !Ref RequestValidator
      RequestModels:
        application/json: !Ref QueryRequestModel
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaFunction.Arn}/invocations"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters: !If
              - EnableCors
              - method.response.header.Access-Control-Allow-Origin: "'*'"
              - !Ref AWS::NoValue
      MethodResponses:
        - StatusCode: 200
          ResponseParameters: !If
            - EnableCors
            - method.response.header.Access-Control-Allow-Origin: false
            - !Ref AWS::NoValue
        - StatusCode: 400
        - StatusCode: 500

  # API Gateway Request Validator
  RequestValidator:
    Type: AWS::ApiGateway::RequestValidator
    Properties:
      RestApiId: !Ref ApiGateway
      Name: "query-validator"
      ValidateRequestBody: true
      ValidateRequestParameters: false

  # API Gateway Request Model
  QueryRequestModel:
    Type: AWS::ApiGateway::Model
    Properties:
      RestApiId: !Ref ApiGateway
      ContentType: application/json
      Name: QueryRequest
      Schema:
        $schema: "http://json-schema.org/draft-04/schema#"
        title: "Query Request Schema"
        type: object
        properties:
          query:
            type: string
            minLength: 1
            maxLength: 1000
            description: "The question to ask the knowledge management assistant"
          sessionId:
            type: string
            minLength: 1
            maxLength: 100
            pattern: "^[a-zA-Z0-9-_]+$"
            description: "Session identifier for conversation continuity"
        required:
          - query
        additionalProperties: false

  # Lambda Permission for API Gateway
  LambdaApiGatewayPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LambdaFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*"

  # CloudWatch Log Group for API Gateway Access Logs
  ApiGatewayLogGroup:
    Type: AWS::Logs::LogGroup
    Condition: EnableLogging
    Properties:
      LogGroupName: !Sub "API-Gateway-Execution-Logs_${ApiGateway}/prod"
      RetentionInDays: !Ref LogRetentionDays

  # API Gateway Account for CloudWatch Logs
  ApiGatewayAccount:
    Type: AWS::ApiGateway::Account
    Condition: EnableLogging
    Properties:
      CloudWatchRoleArn: !GetAtt ApiGatewayCloudWatchRole.Arn

  # IAM Role for API Gateway CloudWatch Logs
  ApiGatewayCloudWatchRole:
    Type: AWS::IAM::Role
    Condition: EnableLogging
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs

  # API Gateway Deployment
  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - QueryPostMethod
      - QueryOptionsMethod
    Properties:
      RestApiId: !Ref ApiGateway
      StageName: prod
      StageDescription:
        Description: "Production stage for Knowledge Management API"
        LoggingLevel: !If [EnableLogging, "INFO", !Ref "AWS::NoValue"]
        DataTraceEnabled: !If [EnableLogging, true, !Ref "AWS::NoValue"]
        MetricsEnabled: !If [EnableMonitoring, true, !Ref "AWS::NoValue"]
        ThrottlingRateLimit: 1000
        ThrottlingBurstLimit: 2000
        AccessLogSetting: !If
          - EnableLogging
          - DestinationArn: !GetAtt ApiGatewayLogGroup.Arn
            Format: '$requestId $ip $caller $user [$requestTime] "$httpMethod $resourcePath $protocol" $status $error.message $error.messageString'
          - !Ref AWS::NoValue

  # CloudWatch Dashboard for monitoring
  MonitoringDashboard:
    Type: AWS::CloudWatch::Dashboard
    Condition: EnableMonitoring
    Properties:
      DashboardName: !Sub "${AWS::StackName}-knowledge-management-dashboard"
      DashboardBody: !Sub |
        {
          "widgets": [
            {
              "type": "metric",
              "x": 0,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "AWS/Lambda", "Invocations", "FunctionName", "${LambdaFunction}" ],
                  [ ".", "Errors", ".", "." ],
                  [ ".", "Duration", ".", "." ]
                ],
                "period": 300,
                "stat": "Sum",
                "region": "${AWS::Region}",
                "title": "Lambda Metrics"
              }
            },
            {
              "type": "metric",
              "x": 12,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "AWS/ApiGateway", "Count", "ApiName", "${ApiGateway}" ],
                  [ ".", "4XXError", ".", "." ],
                  [ ".", "5XXError", ".", "." ],
                  [ ".", "Latency", ".", "." ]
                ],
                "period": 300,
                "stat": "Sum",
                "region": "${AWS::Region}",
                "title": "API Gateway Metrics"
              }
            }
          ]
        }

# Comprehensive Outputs for integration and verification
Outputs:
  # API Endpoints
  ApiEndpoint:
    Description: "API Gateway endpoint URL for the Knowledge Management Assistant"
    Value: !Sub "https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod"
    Export:
      Name: !Sub "${AWS::StackName}-api-endpoint"

  QueryEndpoint:
    Description: "Full endpoint URL for querying the knowledge assistant"
    Value: !Sub "https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod/query"
    Export:
      Name: !Sub "${AWS::StackName}-query-endpoint"

  # Resource Identifiers
  DocumentBucketName:
    Description: "S3 bucket name for document storage"
    Value: !Ref DocumentBucket
    Export:
      Name: !Sub "${AWS::StackName}-document-bucket"

  DocumentBucketArn:
    Description: "S3 bucket ARN for document storage"
    Value: !GetAtt DocumentBucket.Arn
    Export:
      Name: !Sub "${AWS::StackName}-document-bucket-arn"

  KnowledgeBaseId:
    Description: "Bedrock Knowledge Base ID"
    Value: !Ref KnowledgeBase
    Export:
      Name: !Sub "${AWS::StackName}-knowledge-base-id"

  BedrockAgentId:
    Description: "Bedrock Agent ID"
    Value: !GetAtt BedrockAgent.AgentId
    Export:
      Name: !Sub "${AWS::StackName}-agent-id"

  OpenSearchCollectionArn:
    Description: "OpenSearch Serverless collection ARN"
    Value: !GetAtt OpenSearchCollection.Arn
    Export:
      Name: !Sub "${AWS::StackName}-opensearch-collection-arn"

  # Lambda Function Details
  LambdaFunctionArn:
    Description: "Lambda function ARN for API integration"
    Value: !GetAtt LambdaFunction.Arn
    Export:
      Name: !Sub "${AWS::StackName}-lambda-arn"

  # Monitoring Resources
  CloudWatchDashboard:
    Condition: EnableMonitoring
    Description: "CloudWatch Dashboard URL for monitoring"
    Value: !Sub "https://${AWS::Region}.console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${AWS::StackName}-knowledge-management-dashboard"

  # IAM Role ARNs
  BedrockServiceRoleArn:
    Description: "Bedrock service role ARN"
    Value: !GetAtt BedrockServiceRole.Arn
    Export:
      Name: !Sub "${AWS::StackName}-bedrock-role-arn"

  # Sample API Request
  SampleApiRequest:
    Description: "Sample curl command to test the API"
    Value: !Sub |
      curl -X POST https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod/query \
        -H "Content-Type: application/json" \
        -d '{"query": "What is our remote work policy?", "sessionId": "test-session"}'

  # Document Upload Instructions
  DocumentUploadCommand:
    Description: "AWS CLI command to upload documents to the S3 bucket"
    Value: !Sub "aws s3 cp your-document.pdf s3://${DocumentBucket}/documents/"

  # Knowledge Base Sync Command
  SyncKnowledgeBaseCommand:
    Description: "AWS CLI command to start knowledge base ingestion"
    Value: !Sub "aws bedrock-agent start-ingestion-job --knowledge-base-id ${KnowledgeBase} --data-source-id [DATA_SOURCE_ID]"