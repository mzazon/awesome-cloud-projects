"""
Enterprise Identity Federation Authentication Handler

This Lambda function provides custom authentication logic for integrating
enterprise identity providers with Bedrock AgentCore workload identities.
It handles SAML assertion processing, user attribute mapping, and determines
AI agent access permissions based on enterprise roles and department affiliations.

Key Features:
- SAML attribute processing from enterprise identity providers
- Department-based permission mapping for AI agent access
- User authorization validation for AI agent management
- Session context establishment for AgentCore integration
- Comprehensive logging for audit and compliance

Author: Generated by Terraform for Enterprise Identity Federation Recipe
Version: 1.0
Compatible with: Python 3.11+ runtime
"""

import json
import boto3
import logging
import os
from typing import Dict, Any, Optional
from datetime import datetime, timezone

# Configure logging for CloudWatch integration
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Initialize AWS clients (reused across invocations)
cognito_client = None
ssm_client = None

def get_aws_clients():
    """Initialize AWS service clients with proper error handling."""
    global cognito_client, ssm_client
    
    if cognito_client is None:
        cognito_client = boto3.client('cognito-idp')
    
    if ssm_client is None:
        ssm_client = boto3.client('ssm')
    
    return cognito_client, ssm_client

def lambda_handler(event: Dict[str, Any], context) -> Dict[str, Any]:
    """
    Main Lambda handler for enterprise AI agent identity management.
    
    This function processes Cognito User Pool triggers to validate enterprise
    users and determine their AI agent access permissions based on SAML
    attributes and organizational policies.
    
    Args:
        event: Cognito User Pool trigger event containing user attributes
        context: Lambda runtime context
        
    Returns:
        Modified event with authentication response and agent permissions
        
    Raises:
        Exception: For authentication failures or unauthorized access attempts
    """
    try:
        # Extract trigger information and user attributes
        trigger_source = event.get('triggerSource', '')
        user_attributes = event.get('request', {}).get('userAttributes', {})
        user_pool_id = event.get('userPoolId', '')
        
        # Log authentication attempt for audit purposes
        logger.info(f"Processing authentication trigger: {trigger_source}")
        logger.info(f"User Pool ID: {user_pool_id}")
        logger.info(f"User attributes: {json.dumps(sanitize_user_attributes(user_attributes), default=str)}")
        
        # Route to appropriate handler based on trigger source
        if trigger_source == 'PostAuthentication_Authentication':
            return handle_post_authentication(event, user_attributes)
        elif trigger_source == 'PreAuthentication_Authentication':
            return handle_pre_authentication(event, user_attributes)
        elif trigger_source == 'CustomMessage_Authentication':
            return handle_custom_message(event, user_attributes)
        else:
            logger.info(f"No specific handler for trigger: {trigger_source}")
            return event
            
    except Exception as e:
        logger.error(f"Authentication error: {str(e)}")
        logger.error(f"Event: {json.dumps(event, default=str, indent=2)}")
        
        # Re-raise exception to prevent authentication bypass
        raise e

def handle_pre_authentication(event: Dict[str, Any], user_attributes: Dict[str, str]) -> Dict[str, Any]:
    """
    Handle pre-authentication validation.
    
    Validates user eligibility for AI agent access before authentication completes.
    This ensures that only authorized enterprise users can proceed with the
    authentication flow.
    
    Args:
        event: Cognito trigger event
        user_attributes: SAML-mapped user attributes
        
    Returns:
        Unmodified event if validation passes
        
    Raises:
        Exception: If user is not authorized for AI agent access
    """
    email = user_attributes.get('email', '').lower()
    department = user_attributes.get('custom:department', 'general').lower()
    
    logger.info(f"Pre-authentication check for user: {email}")
    
    # Validate user authorization for AI agent management
    if not is_authorized_for_ai_agents(email):
        logger.warning(f"User {email} not authorized for AI agent access")
        raise Exception("User not authorized for AI agent access")
    
    # Validate department mapping exists
    if not get_department_permissions(department):
        logger.warning(f"Invalid department '{department}' for user {email}")
        # Don't fail authentication, but assign general permissions
        logger.info(f"Assigning general permissions to user {email}")
    
    logger.info(f"Pre-authentication successful for {email}")
    return event

def handle_post_authentication(event: Dict[str, Any], user_attributes: Dict[str, str]) -> Dict[str, Any]:
    """
    Handle post-authentication processing.
    
    Processes successful enterprise authentication by determining agent access
    permissions and establishing session context for AgentCore integration.
    
    Args:
        event: Cognito trigger event
        user_attributes: SAML-mapped user attributes
        
    Returns:
        Modified event with agent permissions and session context
    """
    email = user_attributes.get('email', '').lower()
    department = user_attributes.get('custom:department', 'general').lower()
    name = user_attributes.get('name', email)
    
    logger.info(f"Post-authentication processing for user: {email}")
    
    # Determine agent access permissions based on department
    agent_permissions = get_department_permissions(department)
    
    # Create session context for AgentCore integration
    session_context = create_session_context(email, department, agent_permissions)
    
    # Store session information in event response
    response = event.get('response', {})
    response.update({
        'agentPermissions': agent_permissions,
        'sessionContext': session_context,
        'sessionDuration': 3600,  # 1 hour session
        'userDepartment': department,
        'timestamp': datetime.now(timezone.utc).isoformat()
    })
    
    event['response'] = response
    
    # Log successful authentication with permissions
    logger.info(f"Authentication successful for {email} in {department} department")
    logger.info(f"Granted permissions: {json.dumps(agent_permissions, default=str)}")
    
    return event

def handle_custom_message(event: Dict[str, Any], user_attributes: Dict[str, str]) -> Dict[str, Any]:
    """
    Handle custom message generation for enterprise users.
    
    Customizes authentication messages based on user department and
    access level for better user experience.
    
    Args:
        event: Cognito trigger event
        user_attributes: SAML-mapped user attributes
        
    Returns:
        Modified event with custom message
    """
    message_action = event.get('request', {}).get('codeParameter', '')
    department = user_attributes.get('custom:department', 'general').lower()
    name = user_attributes.get('name', 'User')
    
    logger.info(f"Generating custom message for {message_action}")
    
    # Customize message based on department and action
    if message_action == 'verification_code':
        custom_message = generate_verification_message(name, department)
    elif message_action == 'temporary_password':
        custom_message = generate_temporary_password_message(name, department)
    else:
        custom_message = f"Welcome to Enterprise AI Agent Management, {name}!"
    
    # Set custom message in response
    response = event.get('response', {})
    response['emailMessage'] = custom_message
    response['emailSubject'] = f"Enterprise AI Agent Access - {message_action.replace('_', ' ').title()}"
    
    event['response'] = response
    
    return event

def get_department_permissions(department: str) -> Dict[str, Any]:
    """
    Get AI agent access permissions for a specific department.
    
    Args:
        department: User's department from SAML attributes
        
    Returns:
        Dictionary containing department-specific permissions
    """
    # Load permission mapping from environment variable or default
    permission_mapping_str = os.environ.get('PERMISSION_MAPPING', '{}')
    
    try:
        permission_mapping = json.loads(permission_mapping_str)
    except json.JSONDecodeError:
        logger.error("Failed to parse permission mapping from environment")
        permission_mapping = {}
    
    # Default permission structure
    default_permissions = {
        'engineering': {
            'canCreateAgents': True,
            'canDeleteAgents': True,
            'maxAgents': 10,
            'allowedServices': ['bedrock', 's3', 'lambda'],
            'allowedActions': ['create', 'read', 'update', 'delete']
        },
        'security': {
            'canCreateAgents': True,
            'canDeleteAgents': True,
            'maxAgents': 5,
            'allowedServices': ['bedrock', 'iam', 'cloudtrail'],
            'allowedActions': ['create', 'read', 'update', 'delete', 'audit']
        },
        'general': {
            'canCreateAgents': False,
            'canDeleteAgents': False,
            'maxAgents': 2,
            'allowedServices': ['bedrock'],
            'allowedActions': ['read']
        }
    }
    
    # Merge environment configuration with defaults
    merged_permissions = {**default_permissions, **permission_mapping}
    
    # Return department-specific permissions or general as fallback
    return merged_permissions.get(department.lower(), merged_permissions['general'])

def is_authorized_for_ai_agents(email: str) -> bool:
    """
    Check if user is authorized for AI agent management.
    
    Args:
        email: User's email address from SAML attributes
        
    Returns:
        True if user is authorized, False otherwise
    """
    # Load authorized domains from environment variable
    authorized_domains_str = os.environ.get('AUTHORIZED_DOMAINS', '[]')
    
    try:
        authorized_domains = json.loads(authorized_domains_str)
    except json.JSONDecodeError:
        logger.error("Failed to parse authorized domains from environment")
        authorized_domains = ['@company.com', '@enterprise.org']
    
    # Check if user's email domain is in authorized list
    for domain in authorized_domains:
        if domain.lower() in email.lower():
            return True
    
    logger.warning(f"Email domain not authorized: {email}")
    return False

def create_session_context(email: str, department: str, permissions: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create session context for AgentCore integration.
    
    Args:
        email: User's email address
        department: User's department
        permissions: User's agent permissions
        
    Returns:
        Session context dictionary
    """
    return {
        'userId': email,
        'department': department,
        'permissions': permissions,
        'sessionId': f"session_{int(datetime.now(timezone.utc).timestamp())}",
        'agentCoreIdentity': os.environ.get('AGENTCORE_IDENTITY', ''),
        'timestamp': datetime.now(timezone.utc).isoformat(),
        'source': 'enterprise-saml-federation'
    }

def generate_verification_message(name: str, department: str) -> str:
    """Generate customized verification message based on user's department."""
    department_info = {
        'engineering': 'As an engineering team member, you\'ll have full access to AI agent creation and management.',
        'security': 'As a security team member, you\'ll have audit capabilities and enhanced access controls.',
        'general': 'You\'ll have read access to AI agents and basic management capabilities.'
    }
    
    dept_message = department_info.get(department.lower(), department_info['general'])
    
    return f"""Hello {name},

Welcome to Enterprise AI Agent Management!

{dept_message}

Please use the verification code below to complete your authentication:

{{####}}

If you didn't request this verification, please contact your IT administrator.

Best regards,
Enterprise AI Team"""

def generate_temporary_password_message(name: str, department: str) -> str:
    """Generate customized temporary password message."""
    return f"""Hello {name},

Your temporary password for Enterprise AI Agent Management is ready.

Department: {department.title()}

Please use the temporary password below and change it upon first login:

{{####}}

For security reasons, this password will expire in 24 hours.

Best regards,
Enterprise AI Team"""

def sanitize_user_attributes(user_attributes: Dict[str, str]) -> Dict[str, str]:
    """
    Sanitize user attributes for logging purposes.
    
    Removes or masks sensitive information from user attributes
    before logging for security and privacy compliance.
    
    Args:
        user_attributes: Raw user attributes from SAML assertion
        
    Returns:
        Sanitized user attributes safe for logging
    """
    sanitized = {}
    sensitive_fields = ['sub', 'email_verified', 'phone_number', 'address']
    
    for key, value in user_attributes.items():
        if key in sensitive_fields:
            sanitized[key] = '[REDACTED]'
        elif key == 'email':
            # Partially mask email for privacy
            if '@' in value:
                local, domain = value.split('@', 1)
                sanitized[key] = f"{local[:2]}***@{domain}"
            else:
                sanitized[key] = '[INVALID_EMAIL]'
        else:
            sanitized[key] = value
    
    return sanitized

def store_user_session(session_context: Dict[str, Any]) -> Optional[str]:
    """
    Store user session information in Parameter Store for AgentCore integration.
    
    Args:
        session_context: Session context to store
        
    Returns:
        Parameter name if stored successfully, None otherwise
    """
    try:
        _, ssm_client = get_aws_clients()
        
        session_id = session_context.get('sessionId', '')
        parameter_name = f"/enterprise/agentcore/sessions/{session_id}"
        
        ssm_client.put_parameter(
            Name=parameter_name,
            Value=json.dumps(session_context, default=str),
            Type='SecureString',
            Description=f"Session context for user {session_context.get('userId', 'unknown')}",
            Overwrite=True,
            Tags=[
                {'Key': 'Source', 'Value': 'enterprise-identity-federation'},
                {'Key': 'Type', 'Value': 'user-session'},
                {'Key': 'Department', 'Value': session_context.get('department', 'unknown')}
            ]
        )
        
        logger.info(f"Stored session context: {parameter_name}")
        return parameter_name
        
    except Exception as e:
        logger.error(f"Failed to store session context: {str(e)}")
        return None