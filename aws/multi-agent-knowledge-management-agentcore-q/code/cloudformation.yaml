AWSTemplateFormatVersion: '2010-09-09'
Description: 'Multi-Agent Knowledge Management System with Bedrock AgentCore and Q Business - Production-ready infrastructure for enterprise knowledge retrieval with specialized AI agents'

# ============================================================================
# METADATA
# ============================================================================
Metadata:
  'AWS::CloudFormation::Interface':
    ParameterGroups:
      - Label:
          default: 'Project Configuration'
        Parameters:
          - ProjectName
          - Environment
          - RandomSuffix
      - Label:
          default: 'Q Business Configuration'
        Parameters:
          - QBusinessDisplayName
          - QBusinessDescription
          - IndexDisplayName
      - Label:
          default: 'Lambda Configuration'
        Parameters:
          - LambdaRuntime
          - LambdaTimeout
          - LambdaMemorySize
      - Label:
          default: 'API Gateway Configuration'
        Parameters:
          - ApiGatewayCorsEnabled
          - ApiGatewayThrottleRateLimit
          - ApiGatewayThrottleBurstLimit
      - Label:
          default: 'DynamoDB Configuration'
        Parameters:
          - SessionTableBillingMode
          - SessionTableTTLDays
      - Label:
          default: 'Security Configuration'
        Parameters:
          - S3EncryptionEnabled
          - VpcConfig
    ParameterLabels:
      ProjectName:
        default: 'Project Name'
      Environment:
        default: 'Environment'
      RandomSuffix:
        default: 'Random Suffix for Unique Resource Names'

# ============================================================================
# PARAMETERS
# ============================================================================
Parameters:
  # Project Configuration
  ProjectName:
    Type: String
    Default: 'multi-agent-km'
    Description: 'Name of the project for resource naming and tagging'
    AllowedPattern: '^[a-z0-9-]{3,30}$'
    ConstraintDescription: 'Must be 3-30 characters, lowercase letters, numbers, and hyphens only'

  Environment:
    Type: String
    Default: 'dev'
    AllowedValues:
      - dev
      - staging
      - prod
    Description: 'Environment for deployment (affects resource configurations)'

  RandomSuffix:
    Type: String
    Default: 'abc123'
    Description: 'Random suffix for ensuring unique resource names'
    AllowedPattern: '^[a-z0-9]{6}$'
    ConstraintDescription: 'Must be exactly 6 characters, lowercase letters and numbers only'

  # Q Business Configuration
  QBusinessDisplayName:
    Type: String
    Default: 'Enterprise Knowledge Management System'
    Description: 'Display name for Q Business application'
    MaxLength: 100

  QBusinessDescription:
    Type: String
    Default: 'Multi-agent knowledge management with specialized domain expertise'
    Description: 'Description for Q Business application'
    MaxLength: 200

  IndexDisplayName:
    Type: String
    Default: 'Multi-Agent Knowledge Index'
    Description: 'Display name for Q Business index'
    MaxLength: 100

  # Lambda Configuration
  LambdaRuntime:
    Type: String
    Default: 'python3.12'
    AllowedValues:
      - python3.11
      - python3.12
    Description: 'Python runtime version for Lambda functions'

  LambdaTimeout:
    Type: Number
    Default: 60
    MinValue: 30
    MaxValue: 900
    Description: 'Timeout in seconds for Lambda functions'

  LambdaMemorySize:
    Type: Number
    Default: 512
    AllowedValues: [128, 256, 512, 1024, 2048, 3008]
    Description: 'Memory size in MB for Lambda functions'

  # API Gateway Configuration
  ApiGatewayCorsEnabled:
    Type: String
    Default: 'true'
    AllowedValues: ['true', 'false']
    Description: 'Enable CORS for API Gateway'

  ApiGatewayThrottleRateLimit:
    Type: Number
    Default: 500
    MinValue: 1
    MaxValue: 10000
    Description: 'API Gateway throttle rate limit (requests per second)'

  ApiGatewayThrottleBurstLimit:
    Type: Number
    Default: 1000
    MinValue: 1
    MaxValue: 5000
    Description: 'API Gateway throttle burst limit'

  # DynamoDB Configuration
  SessionTableBillingMode:
    Type: String
    Default: 'PAY_PER_REQUEST'
    AllowedValues:
      - PAY_PER_REQUEST
      - PROVISIONED
    Description: 'DynamoDB billing mode for session table'

  SessionTableTTLDays:
    Type: Number
    Default: 30
    MinValue: 1
    MaxValue: 365
    Description: 'TTL in days for session table records'

  # Security Configuration
  S3EncryptionEnabled:
    Type: String
    Default: 'true'
    AllowedValues: ['true', 'false']
    Description: 'Enable server-side encryption for S3 buckets'

  VpcConfig:
    Type: String
    Default: 'false'
    AllowedValues: ['true', 'false']
    Description: 'Deploy Lambda functions in VPC (requires additional VPC configuration)'

# ============================================================================
# CONDITIONS
# ============================================================================
Conditions:
  IsProduction: !Equals [!Ref Environment, 'prod']
  EnableS3Encryption: !Equals [!Ref S3EncryptionEnabled, 'true']
  EnableVpcConfig: !Equals [!Ref VpcConfig, 'true']
  EnableCors: !Equals [!Ref ApiGatewayCorsEnabled, 'true']
  IsProvisionedBilling: !Equals [!Ref SessionTableBillingMode, 'PROVISIONED']

# ============================================================================
# RESOURCES
# ============================================================================
Resources:

  # ============================================================================
  # IAM ROLES AND POLICIES
  # ============================================================================
  
  # IAM Role for Lambda Functions and Q Business
  AgentCoreExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: !Sub '${ProjectName}-agentcore-role-${RandomSuffix}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - qbusiness.amazonaws.com
            Action: 'sts:AssumeRole'
            Condition:
              StringEquals:
                'aws:RequestedRegion': !Ref 'AWS::Region'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
      Policies:
        - PolicyName: AgentCoreCustomPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Bedrock permissions
              - Effect: Allow
                Action:
                  - 'bedrock:InvokeModel'
                  - 'bedrock:InvokeModelWithResponseStream'
                  - 'bedrock:GetFoundationModel'
                  - 'bedrock:ListFoundationModels'
                Resource: 
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/*'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent-alias/*'
              # Q Business permissions
              - Effect: Allow
                Action:
                  - 'qbusiness:ChatSync'
                  - 'qbusiness:Chat'
                  - 'qbusiness:GetApplication'
                  - 'qbusiness:GetIndex'
                  - 'qbusiness:GetDataSource'
                  - 'qbusiness:CreateConversation'
                  - 'qbusiness:GetConversation'
                  - 'qbusiness:ListConversations'
                  - 'qbusiness:DeleteConversation'
                  - 'qbusiness:PutFeedback'
                Resource: 
                  - !Sub 'arn:aws:qbusiness:${AWS::Region}:${AWS::AccountId}:application/*'
                  - !Sub 'arn:aws:qbusiness:${AWS::Region}:${AWS::AccountId}:index/*'
                  - !Sub 'arn:aws:qbusiness:${AWS::Region}:${AWS::AccountId}:data-source/*'
              # S3 permissions
              - Effect: Allow
                Action:
                  - 's3:GetObject'
                  - 's3:GetObjectVersion'
                  - 's3:ListBucket'
                  - 's3:GetBucketLocation'
                Resource:
                  - !Sub '${FinanceKnowledgeBucket}/*'
                  - !Ref FinanceKnowledgeBucket
                  - !Sub '${HRKnowledgeBucket}/*'
                  - !Ref HRKnowledgeBucket
                  - !Sub '${TechnicalKnowledgeBucket}/*'
                  - !Ref TechnicalKnowledgeBucket
              # DynamoDB permissions
              - Effect: Allow
                Action:
                  - 'dynamodb:PutItem'
                  - 'dynamodb:GetItem'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:DeleteItem'
                  - 'dynamodb:Query'
                  - 'dynamodb:Scan'
                Resource: !GetAtt SessionTable.Arn
              # Lambda invoke permissions for agent coordination
              - Effect: Allow
                Action:
                  - 'lambda:InvokeFunction'
                Resource:
                  - !GetAtt FinanceAgentFunction.Arn
                  - !GetAtt HRAgentFunction.Arn
                  - !GetAtt TechnicalAgentFunction.Arn
              # CloudWatch Logs permissions
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'IAM'

  # ============================================================================
  # S3 BUCKETS FOR KNOWLEDGE BASES
  # ============================================================================

  # Finance Knowledge Base Bucket
  FinanceKnowledgeBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: !Sub '${ProjectName}-finance-kb-${RandomSuffix}'
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption: !If
        - EnableS3Encryption
        - ServerSideEncryptionConfiguration:
            - ServerSideEncryptionByDefault:
                SSEAlgorithm: AES256
              BucketKeyEnabled: true
        - !Ref 'AWS::NoValue'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteIncompleteMultipartUploads
            Status: Enabled
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 7
          - Id: TransitionToIA
            Status: Enabled
            Transition:
              StorageClass: STANDARD_IA
              TransitionInDays: 30
      NotificationConfiguration:
        CloudWatchConfigurations:
          - Event: 's3:ObjectCreated:*'
            CloudWatchConfiguration:
              LogGroupName: !Sub '/aws/s3/${ProjectName}-finance-kb-${RandomSuffix}'
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'Storage'
        - Key: Domain
          Value: 'Finance'

  # HR Knowledge Base Bucket
  HRKnowledgeBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: !Sub '${ProjectName}-hr-kb-${RandomSuffix}'
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption: !If
        - EnableS3Encryption
        - ServerSideEncryptionConfiguration:
            - ServerSideEncryptionByDefault:
                SSEAlgorithm: AES256
              BucketKeyEnabled: true
        - !Ref 'AWS::NoValue'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteIncompleteMultipartUploads
            Status: Enabled
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 7
          - Id: TransitionToIA
            Status: Enabled
            Transition:
              StorageClass: STANDARD_IA
              TransitionInDays: 30
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'Storage'
        - Key: Domain
          Value: 'HR'

  # Technical Knowledge Base Bucket
  TechnicalKnowledgeBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: !Sub '${ProjectName}-tech-kb-${RandomSuffix}'
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption: !If
        - EnableS3Encryption
        - ServerSideEncryptionConfiguration:
            - ServerSideEncryptionByDefault:
                SSEAlgorithm: AES256
              BucketKeyEnabled: true
        - !Ref 'AWS::NoValue'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteIncompleteMultipartUploads
            Status: Enabled
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 7
          - Id: TransitionToIA
            Status: Enabled
            Transition:
              StorageClass: STANDARD_IA
              TransitionInDays: 30
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'Storage'
        - Key: Domain
          Value: 'Technical'

  # ============================================================================
  # Q BUSINESS APPLICATION AND COMPONENTS
  # ============================================================================

  # Q Business Application
  QBusinessApplication:
    Type: 'AWS::QBusiness::Application'
    Properties:
      DisplayName: !Ref QBusinessDisplayName
      Description: !Ref QBusinessDescription
      RoleArn: !GetAtt AgentCoreExecutionRole.Arn
      EncryptionConfiguration:
        KmsKeyId: alias/aws/qbusiness
      AttachmentsConfiguration:
        AttachmentsControlMode: ENABLED
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'QBusiness'

  # Q Business Index
  QBusinessIndex:
    Type: 'AWS::QBusiness::Index'
    Properties:
      ApplicationId: !Ref QBusinessApplication
      DisplayName: !Ref IndexDisplayName
      Description: 'Centralized index for multi-agent knowledge retrieval'
      Type: ENTERPRISE
      CapacityConfiguration:
        Units: 1
      DocumentAttributeConfigurations:
        - Name: 'department'
          Type: STRING_VALUE
          Search: ENABLED
        - Name: 'type'
          Type: STRING_VALUE
          Search: ENABLED
        - Name: 'version'
          Type: STRING_VALUE
          Search: ENABLED
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'QBusiness'

  # Finance Data Source
  FinanceDataSource:
    Type: 'AWS::QBusiness::DataSource'
    Properties:
      ApplicationId: !Ref QBusinessApplication
      IndexId: !Ref QBusinessIndex
      DisplayName: 'Finance Knowledge Base'
      Description: 'Finance policies and procedures knowledge source'
      Configuration:
        type: S3
        syncMode: FULL_CRAWL
        connectionConfiguration:
          repositoryEndpointMetadata:
            BucketName: !Ref FinanceKnowledgeBucket
        repositoryConfigurations:
          document:
            fieldMappings:
              - indexFieldName: 'department'
                indexFieldType: STRING_VALUE
                dataSourceFieldName: 'department'
              - indexFieldName: 'type'
                indexFieldType: STRING_VALUE
                dataSourceFieldName: 'type'
              - indexFieldName: 'version'
                indexFieldType: STRING_VALUE
                dataSourceFieldName: 'version'
      RoleArn: !GetAtt AgentCoreExecutionRole.Arn
      SyncSchedule: 'rate(1 day)'
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'QBusiness'
        - Key: Domain
          Value: 'Finance'

  # HR Data Source
  HRDataSource:
    Type: 'AWS::QBusiness::DataSource'
    Properties:
      ApplicationId: !Ref QBusinessApplication
      IndexId: !Ref QBusinessIndex
      DisplayName: 'HR Knowledge Base'
      Description: 'HR policies and employee procedures knowledge source'
      Configuration:
        type: S3
        syncMode: FULL_CRAWL
        connectionConfiguration:
          repositoryEndpointMetadata:
            BucketName: !Ref HRKnowledgeBucket
        repositoryConfigurations:
          document:
            fieldMappings:
              - indexFieldName: 'department'
                indexFieldType: STRING_VALUE
                dataSourceFieldName: 'department'
              - indexFieldName: 'type'
                indexFieldType: STRING_VALUE
                dataSourceFieldName: 'type'
              - indexFieldName: 'version'
                indexFieldType: STRING_VALUE
                dataSourceFieldName: 'version'
      RoleArn: !GetAtt AgentCoreExecutionRole.Arn
      SyncSchedule: 'rate(1 day)'
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'QBusiness'
        - Key: Domain
          Value: 'HR'

  # Technical Data Source
  TechnicalDataSource:
    Type: 'AWS::QBusiness::DataSource'
    Properties:
      ApplicationId: !Ref QBusinessApplication
      IndexId: !Ref QBusinessIndex
      DisplayName: 'Technical Knowledge Base'
      Description: 'Technical documentation and system procedures knowledge source'
      Configuration:
        type: S3
        syncMode: FULL_CRAWL
        connectionConfiguration:
          repositoryEndpointMetadata:
            BucketName: !Ref TechnicalKnowledgeBucket
        repositoryConfigurations:
          document:
            fieldMappings:
              - indexFieldName: 'department'
                indexFieldType: STRING_VALUE
                dataSourceFieldName: 'department'
              - indexFieldName: 'type'
                indexFieldType: STRING_VALUE
                dataSourceFieldName: 'type'
              - indexFieldName: 'version'
                indexFieldType: STRING_VALUE
                dataSourceFieldName: 'version'
      RoleArn: !GetAtt AgentCoreExecutionRole.Arn
      SyncSchedule: 'rate(1 day)'
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'QBusiness'
        - Key: Domain
          Value: 'Technical'

  # ============================================================================
  # DYNAMODB SESSION TABLE
  # ============================================================================

  # Session Management Table
  SessionTable:
    Type: 'AWS::DynamoDB::Table'
    Properties:
      TableName: !Sub '${ProjectName}-agent-sessions-${RandomSuffix}'
      BillingMode: !Ref SessionTableBillingMode
      AttributeDefinitions:
        - AttributeName: sessionId
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: S
      KeySchema:
        - AttributeName: sessionId
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: !If [IsProduction, true, false]
      SSESpecification:
        SSEEnabled: true
        KMSMasterKeyId: alias/aws/dynamodb
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'Database'

  # ============================================================================
  # LAMBDA FUNCTIONS
  # ============================================================================

  # Supervisor Agent Lambda Function
  SupervisorAgentFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: !Sub '${ProjectName}-supervisor-agent-${RandomSuffix}'
      Description: 'Supervisor agent that coordinates specialized agents for knowledge retrieval'
      Runtime: !Ref LambdaRuntime
      Handler: 'index.lambda_handler'
      Timeout: !Ref LambdaTimeout
      MemorySize: !Ref LambdaMemorySize
      Role: !GetAtt AgentCoreExecutionRole.Arn
      Environment:
        Variables:
          RANDOM_SUFFIX: !Ref RandomSuffix
          SESSION_TABLE: !Ref SessionTable
          FINANCE_FUNCTION_NAME: !Ref FinanceAgentFunction
          HR_FUNCTION_NAME: !Ref HRAgentFunction
          TECHNICAL_FUNCTION_NAME: !Ref TechnicalAgentFunction
          Q_APP_ID: !Ref QBusinessApplication
          PROJECT_NAME: !Ref ProjectName
          ENVIRONMENT: !Ref Environment
      ReservedConcurrencyConfiguration: !If
        - IsProduction
        - ReservedConcurrency: 100
        - !Ref 'AWS::NoValue'
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from typing import List, Dict, Any
          import uuid
          import logging

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              """
              Supervisor agent that coordinates specialized agents for knowledge retrieval
              """
              try:
                  # Initialize AWS clients
                  lambda_client = boto3.client('lambda')
                  dynamodb = boto3.resource('dynamodb')
                  
                  # Parse request
                  if 'body' in event:
                      body = json.loads(event['body']) if isinstance(event['body'], str) else event['body']
                  else:
                      body = event
                  
                  query = body.get('query', '')
                  session_id = body.get('sessionId', str(uuid.uuid4()))
                  
                  logger.info(f"Processing query: {query} for session: {session_id}")
                  
                  # Health check endpoint
                  if event.get('httpMethod') == 'GET' and event.get('path') == '/health':
                      return {
                          'statusCode': 200,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({'status': 'healthy', 'service': 'supervisor-agent'})
                      }
                  
                  if not query:
                      return {
                          'statusCode': 400,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({'error': 'Query parameter is required'})
                      }
                  
                  # Determine which agents to engage
                  agents_to_engage = determine_agents(query)
                  logger.info(f"Engaging agents: {agents_to_engage}")
                  
                  # Collect responses from specialized agents
                  agent_responses = []
                  for agent_name in agents_to_engage:
                      try:
                          response = invoke_specialized_agent(lambda_client, agent_name, query, session_id)
                          agent_responses.append({
                              'agent': agent_name,
                              'response': response,
                              'confidence': calculate_confidence(agent_name, query)
                          })
                      except Exception as e:
                          logger.error(f"Error invoking {agent_name} agent: {str(e)}")
                          agent_responses.append({
                              'agent': agent_name,
                              'response': f"Error retrieving {agent_name} information",
                              'confidence': 0.0
                          })
                  
                  # Synthesize comprehensive answer
                  final_response = synthesize_responses(query, agent_responses)
                  
                  # Store session information
                  store_session_context(session_id, query, final_response, agents_to_engage)
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({
                          'query': query,
                          'response': final_response,
                          'agents_consulted': agents_to_engage,
                          'session_id': session_id,
                          'confidence_scores': {resp['agent']: resp['confidence'] for resp in agent_responses}
                      })
                  }
                  
              except Exception as e:
                  logger.error(f"Supervisor agent error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {'Content-Type': 'application/json'},
                      'body': json.dumps({'error': f"Supervisor agent error: {str(e)}"})
                  }

          def determine_agents(query: str) -> List[str]:
              """Determine which specialized agents to engage based on query analysis"""
              query_lower = query.lower()
              agents = []
              
              # Finance-related keywords
              finance_keywords = ['budget', 'expense', 'cost', 'finance', 'money', 'approval', 
                                 'reimbursement', 'travel', 'spending', 'capital', 'cfo']
              if any(word in query_lower for word in finance_keywords):
                  agents.append('finance')
              
              # HR-related keywords
              hr_keywords = ['employee', 'hr', 'vacation', 'onboard', 'performance', 'leave',
                             'remote', 'work', 'benefits', 'policy', 'review', 'sick']
              if any(word in query_lower for word in hr_keywords):
                  agents.append('hr')
              
              # Technical-related keywords
              tech_keywords = ['technical', 'code', 'api', 'database', 'security', 'backup',
                               'system', 'development', 'infrastructure', 'server', 'ssl']
              if any(word in query_lower for word in tech_keywords):
                  agents.append('technical')
              
              return agents if agents else ['finance', 'hr', 'technical']

          def calculate_confidence(agent_name: str, query: str) -> float:
              """Calculate confidence score for agent relevance to query"""
              query_lower = query.lower()
              
              if agent_name == 'finance':
                  finance_keywords = ['budget', 'expense', 'cost', 'finance', 'money', 'approval']
                  matches = sum(1 for word in finance_keywords if word in query_lower)
                  return min(matches * 0.2, 1.0)
              elif agent_name == 'hr':
                  hr_keywords = ['employee', 'hr', 'vacation', 'onboard', 'performance', 'leave']
                  matches = sum(1 for word in hr_keywords if word in query_lower)
                  return min(matches * 0.2, 1.0)
              elif agent_name == 'technical':
                  tech_keywords = ['technical', 'code', 'api', 'database', 'security', 'backup']
                  matches = sum(1 for word in tech_keywords if word in query_lower)
                  return min(matches * 0.2, 1.0)
              
              return 0.5

          def invoke_specialized_agent(lambda_client, agent_name: str, query: str, session_id: str) -> str:
              """Invoke a specialized agent Lambda function"""
              function_name = os.environ.get(f'{agent_name.upper()}_FUNCTION_NAME')
              
              try:
                  response = lambda_client.invoke(
                      FunctionName=function_name,
                      InvocationType='RequestResponse',
                      Payload=json.dumps({
                          'query': query,
                          'sessionId': session_id,
                          'context': f"Domain-specific query for {agent_name} expertise"
                      })
                  )
                  
                  result = json.loads(response['Payload'].read())
                  if result.get('statusCode') == 200:
                      body = json.loads(result.get('body', '{}'))
                      return body.get('response', f"No {agent_name} information available")
                  else:
                      return f"Error retrieving {agent_name} information"
                      
              except Exception as e:
                  logger.error(f"Error invoking {agent_name} agent: {str(e)}")
                  return f"Error accessing {agent_name} knowledge base"

          def synthesize_responses(query: str, responses: List[Dict]) -> str:
              """Synthesize responses from multiple agents"""
              if not responses:
                  return "No relevant information found in the knowledge base."
              
              high_confidence_responses = [r for r in responses if r.get('confidence', 0) > 0.3]
              responses_to_use = high_confidence_responses if high_confidence_responses else responses
              
              synthesis = f"Based on consultation with {len(responses_to_use)} specialized knowledge domains:\n\n"
              
              for resp in responses_to_use:
                  if resp['response'] and not resp['response'].startswith('Error'):
                      confidence_indicator = "ðŸ”·" if resp.get('confidence', 0) > 0.6 else "ðŸ”¹"
                      synthesis += f"{confidence_indicator} **{resp['agent'].title()} Domain**: {resp['response']}\n\n"
              
              synthesis += "\n*This response was generated by consulting multiple specialized knowledge agents.*"
              return synthesis

          def store_session_context(session_id: str, query: str, response: str, agents: List[str]):
              """Store session context"""
              try:
                  import time
                  table_name = os.environ.get('SESSION_TABLE')
                  dynamodb = boto3.resource('dynamodb')
                  table = dynamodb.Table(table_name)
                  
                  current_time = int(time.time())
                  ttl_time = current_time + (30 * 24 * 60 * 60)  # 30 days TTL
                  
                  table.put_item(
                      Item={
                          'sessionId': session_id,
                          'timestamp': str(current_time),
                          'query': query,
                          'response': response,
                          'agents_consulted': agents,
                          'ttl': ttl_time
                      }
                  )
              except Exception as e:
                  logger.error(f"Error storing session context: {str(e)}")
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'Lambda'
        - Key: AgentType
          Value: 'Supervisor'

  # Finance Agent Lambda Function
  FinanceAgentFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: !Sub '${ProjectName}-finance-agent-${RandomSuffix}'
      Description: 'Finance specialist agent for budget and financial policy queries'
      Runtime: !Ref LambdaRuntime
      Handler: 'index.lambda_handler'
      Timeout: 30
      MemorySize: 256
      Role: !GetAtt AgentCoreExecutionRole.Arn
      Environment:
        Variables:
          Q_APP_ID: !Ref QBusinessApplication
          PROJECT_NAME: !Ref ProjectName
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging
          import uuid

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              """Finance specialist agent for budget and financial policy queries"""
              try:
                  qbusiness = boto3.client('qbusiness')
                  
                  query = event.get('query', '')
                  session_id = event.get('sessionId', str(uuid.uuid4()))
                  
                  logger.info(f"Finance agent processing query: {query}")
                  
                  # Try Q Business integration with fallback
                  try:
                      conversation_response = qbusiness.create_conversation(
                          applicationId=os.environ['Q_APP_ID'],
                          title=f"Finance Query - {session_id[:8]}"
                      )
                      conversation_id = conversation_response['conversationId']
                      
                      chat_response = qbusiness.chat_sync(
                          applicationId=os.environ['Q_APP_ID'],
                          conversationId=conversation_id,
                          userMessage=f"Finance policy and budget context: {query}. Focus on financial procedures, approval processes, and budget guidelines.",
                          userGroups=['finance'],
                          userId='finance-agent'
                      )
                      
                      system_message = chat_response.get('systemMessage', '')
                      source_attributions = chat_response.get('sourceAttributions', [])
                      
                      formatted_response = format_finance_response(system_message, source_attributions, query)
                      
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'agent': 'finance',
                              'response': formatted_response,
                              'sources': [attr.get('title', 'Finance Policy') for attr in source_attributions],
                              'conversation_id': conversation_id
                          })
                      }
                      
                  except Exception as qb_error:
                      logger.error(f"Q Business error: {str(qb_error)}")
                      fallback_response = get_finance_fallback(query)
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'agent': 'finance',
                              'response': fallback_response,
                              'sources': ['Finance Policy Documentation'],
                              'note': 'Fallback response due to Q Business unavailability'
                          })
                      }
                      
              except Exception as e:
                  logger.error(f"Finance agent error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': f"Finance agent error: {str(e)}"})
                  }

          def format_finance_response(message: str, sources: list, query: str) -> str:
              """Format finance response with context and sources"""
              if not message:
                  return get_finance_fallback(query)
              
              formatted = f"Financial Policy Information:\n{message}"
              
              if sources:
                  formatted += f"\n\nSources consulted: {', '.join([s.get('title', 'Unknown') for s in sources])}"
              
              return formatted

          def get_finance_fallback(query: str) -> str:
              """Provide fallback finance information"""
              query_lower = query.lower()
              
              if 'expense' in query_lower or 'approval' in query_lower:
                  return "Expense approval process: Expenses over $1000 require manager approval, over $5000 require director approval, and over $10000 require CFO approval."
              elif 'budget' in query_lower:
                  return "Budget management: Quarterly reviews conducted in March, June, September, December. Annual allocations updated in January."
              elif 'travel' in query_lower or 'reimbursement' in query_lower:
                  return "Travel policy: Reimbursement requires receipts within 30 days. International travel needs 2-week pre-approval. Daily allowances: $75 domestic, $100 international."
              else:
                  return "Finance policies cover expense approvals, budget management, and travel procedures. Specific policies require review of complete documentation."
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'Lambda'
        - Key: AgentType
          Value: 'Finance'

  # HR Agent Lambda Function
  HRAgentFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: !Sub '${ProjectName}-hr-agent-${RandomSuffix}'
      Description: 'HR specialist agent for employee and policy queries'
      Runtime: !Ref LambdaRuntime
      Handler: 'index.lambda_handler'
      Timeout: 30
      MemorySize: 256
      Role: !GetAtt AgentCoreExecutionRole.Arn
      Environment:
        Variables:
          Q_APP_ID: !Ref QBusinessApplication
          PROJECT_NAME: !Ref ProjectName
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging
          import uuid

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              """HR specialist agent for employee and policy queries"""
              try:
                  qbusiness = boto3.client('qbusiness')
                  
                  query = event.get('query', '')
                  session_id = event.get('sessionId', str(uuid.uuid4()))
                  
                  logger.info(f"HR agent processing query: {query}")
                  
                  try:
                      conversation_response = qbusiness.create_conversation(
                          applicationId=os.environ['Q_APP_ID'],
                          title=f"HR Query - {session_id[:8]}"
                      )
                      conversation_id = conversation_response['conversationId']
                      
                      chat_response = qbusiness.chat_sync(
                          applicationId=os.environ['Q_APP_ID'],
                          conversationId=conversation_id,
                          userMessage=f"HR policy and employee procedures context: {query}. Focus on employee policies, benefits, performance management, and workplace procedures.",
                          userGroups=['hr'],
                          userId='hr-agent'
                      )
                      
                      system_message = chat_response.get('systemMessage', '')
                      source_attributions = chat_response.get('sourceAttributions', [])
                      
                      formatted_response = format_hr_response(system_message, source_attributions, query)
                      
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'agent': 'hr',
                              'response': formatted_response,
                              'sources': [attr.get('title', 'HR Handbook') for attr in source_attributions],
                              'conversation_id': conversation_id
                          })
                      }
                      
                  except Exception as qb_error:
                      logger.error(f"Q Business error: {str(qb_error)}")
                      fallback_response = get_hr_fallback(query)
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'agent': 'hr',
                              'response': fallback_response,
                              'sources': ['HR Handbook and Policies'],
                              'note': 'Fallback response due to Q Business unavailability'
                          })
                      }
                      
              except Exception as e:
                  logger.error(f"HR agent error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': f"HR agent error: {str(e)}"})
                  }

          def format_hr_response(message: str, sources: list, query: str) -> str:
              """Format HR response with appropriate context"""
              if not message:
                  return get_hr_fallback(query)
              
              formatted = f"HR Policy Information:\n{message}"
              
              if sources:
                  formatted += f"\n\nSources: {', '.join([s.get('title', 'Unknown') for s in sources])}"
              
              formatted += "\n\n*Note: HR information is confidential and subject to privacy policies.*"
              
              return formatted

          def get_hr_fallback(query: str) -> str:
              """Provide fallback HR information"""
              query_lower = query.lower()
              
              if 'onboard' in query_lower:
                  return "Onboarding process: 3-5 business days completion, IT setup on first day, benefits enrollment within 30 days of start date."
              elif 'performance' in query_lower or 'review' in query_lower:
                  return "Performance management: Annual reviews in Q4, mid-year check-ins in Q2, performance improvement plans have 90-day duration."
              elif 'vacation' in query_lower or 'leave' in query_lower:
                  return "Time off policies: Vacation requires 2-week advance notice, 10 sick days annually (5 carry-over), 12 weeks paid parental leave plus 4 weeks unpaid."
              elif 'remote' in query_lower or 'work' in query_lower:
                  return "Remote work policy: Up to 3 days per week remote work allowed, subject to role requirements and manager approval."
              else:
                  return "HR policies cover onboarding, performance management, time off, and workplace procedures. Consult complete handbook for specific guidance."
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'Lambda'
        - Key: AgentType
          Value: 'HR'

  # Technical Agent Lambda Function
  TechnicalAgentFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: !Sub '${ProjectName}-technical-agent-${RandomSuffix}'
      Description: 'Technical specialist agent for engineering and system queries'
      Runtime: !Ref LambdaRuntime
      Handler: 'index.lambda_handler'
      Timeout: 30
      MemorySize: 256
      Role: !GetAtt AgentCoreExecutionRole.Arn
      Environment:
        Variables:
          Q_APP_ID: !Ref QBusinessApplication
          PROJECT_NAME: !Ref ProjectName
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging
          import uuid

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              """Technical specialist agent for engineering and system queries"""
              try:
                  qbusiness = boto3.client('qbusiness')
                  
                  query = event.get('query', '')
                  session_id = event.get('sessionId', str(uuid.uuid4()))
                  
                  logger.info(f"Technical agent processing query: {query}")
                  
                  try:
                      conversation_response = qbusiness.create_conversation(
                          applicationId=os.environ['Q_APP_ID'],
                          title=f"Technical Query - {session_id[:8]}"
                      )
                      conversation_id = conversation_response['conversationId']
                      
                      chat_response = qbusiness.chat_sync(
                          applicationId=os.environ['Q_APP_ID'],
                          conversationId=conversation_id,
                          userMessage=f"Technical documentation and system procedures context: {query}. Focus on development standards, infrastructure management, API guidelines, and security procedures.",
                          userGroups=['engineering'],
                          userId='technical-agent'
                      )
                      
                      system_message = chat_response.get('systemMessage', '')
                      source_attributions = chat_response.get('sourceAttributions', [])
                      
                      formatted_response = format_technical_response(system_message, source_attributions, query)
                      
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'agent': 'technical',
                              'response': formatted_response,
                              'sources': [attr.get('title', 'Technical Guidelines') for attr in source_attributions],
                              'conversation_id': conversation_id
                          })
                      }
                      
                  except Exception as qb_error:
                      logger.error(f"Q Business error: {str(qb_error)}")
                      fallback_response = get_technical_fallback(query)
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'agent': 'technical',
                              'response': fallback_response,
                              'sources': ['Technical Guidelines Documentation'],
                              'note': 'Fallback response due to Q Business unavailability'
                          })
                      }
                      
              except Exception as e:
                  logger.error(f"Technical agent error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': f"Technical agent error: {str(e)}"})
                  }

          def format_technical_response(message: str, sources: list, query: str) -> str:
              """Format technical response with appropriate context"""
              if not message:
                  return get_technical_fallback(query)
              
              formatted = f"Technical Documentation:\n{message}"
              
              if sources:
                  formatted += f"\n\nReferences: {', '.join([s.get('title', 'Unknown') for s in sources])}"
              
              formatted += "\n\n*Ensure all implementations follow current security and development standards.*"
              
              return formatted

          def get_technical_fallback(query: str) -> str:
              """Provide fallback technical information"""
              query_lower = query.lower()
              
              if 'code' in query_lower or 'development' in query_lower:
                  return "Development standards: All code requires automated testing before deployment, minimum 80% code coverage for production, security scans for external applications."
              elif 'backup' in query_lower or 'database' in query_lower:
                  return "Infrastructure management: Database backups performed nightly at 2 AM UTC, 30-day local retention, 90-day archive retention, quarterly DR testing."
              elif 'api' in query_lower:
                  return "API standards: 1000 requests per minute rate limit, authentication required for all endpoints, SSL/TLS 1.2 minimum for communications."
              elif 'security' in query_lower:
                  return "Security procedures: Security patching within 48 hours for critical vulnerabilities, SSL/TLS 1.2 minimum, authentication required for all API endpoints."
              else:
                  return "Technical guidelines cover development standards, infrastructure management, API protocols, and security procedures. Consult complete documentation for implementation details."
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'Lambda'
        - Key: AgentType
          Value: 'Technical'

  # ============================================================================
  # API GATEWAY
  # ============================================================================

  # API Gateway HTTP API
  MultiAgentAPI:
    Type: 'AWS::ApiGatewayV2::Api'
    Properties:
      Name: !Sub '${ProjectName}-multi-agent-api-${RandomSuffix}'
      Description: 'Multi-agent knowledge management API with enterprise features'
      ProtocolType: HTTP
      CorsConfiguration: !If
        - EnableCors
        - AllowCredentials: false
          AllowHeaders:
            - Content-Type
            - Authorization
            - X-Requested-With
          AllowMethods:
            - GET
            - POST
            - OPTIONS
          AllowOrigins:
            - '*'
          MaxAge: 86400
        - !Ref 'AWS::NoValue'
      Tags:
        Project: !Ref ProjectName
        Environment: !Ref Environment
        Component: 'API'

  # Lambda Integration
  SupervisorIntegration:
    Type: 'AWS::ApiGatewayV2::Integration'
    Properties:
      ApiId: !Ref MultiAgentAPI
      IntegrationType: AWS_PROXY
      IntegrationMethod: POST
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SupervisorAgentFunction.Arn}/invocations'
      PayloadFormatVersion: '2.0'
      TimeoutInMillis: 29000

  # Query Processing Route
  QueryRoute:
    Type: 'AWS::ApiGatewayV2::Route'
    Properties:
      ApiId: !Ref MultiAgentAPI
      RouteKey: 'POST /query'
      Target: !Sub 'integrations/${SupervisorIntegration}'
      AuthorizationType: NONE

  # Health Check Route
  HealthRoute:
    Type: 'AWS::ApiGatewayV2::Route'
    Properties:
      ApiId: !Ref MultiAgentAPI
      RouteKey: 'GET /health'
      Target: !Sub 'integrations/${SupervisorIntegration}'
      AuthorizationType: NONE

  # Production Stage
  ProductionStage:
    Type: 'AWS::ApiGatewayV2::Stage'
    Properties:
      ApiId: !Ref MultiAgentAPI
      StageName: prod
      AutoDeploy: true
      Description: 'Production stage for multi-agent knowledge management'
      ThrottleSettings:
        RateLimit: !Ref ApiGatewayThrottleRateLimit
        BurstLimit: !Ref ApiGatewayThrottleBurstLimit
      AccessLogSettings:
        DestinationArn: !GetAtt ApiLogGroup.Arn
        Format: >
          {
            "requestId": "$context.requestId",
            "requestTime": "$context.requestTime",
            "httpMethod": "$context.httpMethod",
            "path": "$context.path",
            "status": "$context.status",
            "responseLength": "$context.responseLength",
            "responseTime": "$context.responseTime",
            "error": "$context.error.message"
          }
      Tags:
        Project: !Ref ProjectName
        Environment: !Ref Environment
        Component: 'API'

  # API Gateway Lambda Permission
  ApiGatewayLambdaPermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: !Ref SupervisorAgentFunction
      Action: 'lambda:InvokeFunction'
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${MultiAgentAPI}/*/*'

  # ============================================================================
  # CLOUDWATCH LOGS
  # ============================================================================

  # API Gateway Access Logs
  ApiLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Properties:
      LogGroupName: !Sub '/aws/apigateway/${ProjectName}-multi-agent-api-${RandomSuffix}'
      RetentionInDays: !If [IsProduction, 30, 7]
      KmsKeyId: !If
        - IsProduction
        - !GetAtt LogsKMSKey.Arn
        - !Ref 'AWS::NoValue'

  # KMS Key for CloudWatch Logs (Production only)
  LogsKMSKey:
    Type: 'AWS::KMS::Key'
    Condition: IsProduction
    Properties:
      Description: 'KMS Key for CloudWatch Logs encryption'
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: 'kms:*'
            Resource: '*'
          - Sid: Allow CloudWatch Logs
            Effect: Allow
            Principal:
              Service: !Sub 'logs.${AWS::Region}.amazonaws.com'
            Action:
              - 'kms:Encrypt'
              - 'kms:Decrypt'
              - 'kms:ReEncrypt*'
              - 'kms:GenerateDataKey*'
              - 'kms:DescribeKey'
            Resource: '*'
      Tags:
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment
        - Key: Component
          Value: 'Security'

  LogsKMSKeyAlias:
    Type: 'AWS::KMS::Alias'
    Condition: IsProduction
    Properties:
      AliasName: !Sub 'alias/${ProjectName}-logs-${RandomSuffix}'
      TargetKeyId: !Ref LogsKMSKey

# ============================================================================
# OUTPUTS
# ============================================================================
Outputs:
  # API Gateway Outputs
  ApiEndpoint:
    Description: 'API Gateway endpoint URL for multi-agent knowledge management'
    Value: !Sub 'https://${MultiAgentAPI}.execute-api.${AWS::Region}.amazonaws.com/prod'
    Export:
      Name: !Sub '${AWS::StackName}-ApiEndpoint'

  ApiId:
    Description: 'API Gateway ID'
    Value: !Ref MultiAgentAPI
    Export:
      Name: !Sub '${AWS::StackName}-ApiId'

  # Q Business Outputs
  QBusinessApplicationId:
    Description: 'Q Business Application ID'
    Value: !Ref QBusinessApplication
    Export:
      Name: !Sub '${AWS::StackName}-QBusinessApplicationId'

  QBusinessIndexId:
    Description: 'Q Business Index ID'
    Value: !Ref QBusinessIndex
    Export:
      Name: !Sub '${AWS::StackName}-QBusinessIndexId'

  # Data Source Outputs
  FinanceDataSourceId:
    Description: 'Finance knowledge base data source ID'
    Value: !Ref FinanceDataSource
    Export:
      Name: !Sub '${AWS::StackName}-FinanceDataSourceId'

  HRDataSourceId:
    Description: 'HR knowledge base data source ID'
    Value: !Ref HRDataSource
    Export:
      Name: !Sub '${AWS::StackName}-HRDataSourceId'

  TechnicalDataSourceId:
    Description: 'Technical knowledge base data source ID'
    Value: !Ref TechnicalDataSource
    Export:
      Name: !Sub '${AWS::StackName}-TechnicalDataSourceId'

  # S3 Bucket Outputs
  FinanceKnowledgeBucketName:
    Description: 'Finance knowledge base S3 bucket name'
    Value: !Ref FinanceKnowledgeBucket
    Export:
      Name: !Sub '${AWS::StackName}-FinanceKnowledgeBucket'

  HRKnowledgeBucketName:
    Description: 'HR knowledge base S3 bucket name'
    Value: !Ref HRKnowledgeBucket
    Export:
      Name: !Sub '${AWS::StackName}-HRKnowledgeBucket'

  TechnicalKnowledgeBucketName:
    Description: 'Technical knowledge base S3 bucket name'
    Value: !Ref TechnicalKnowledgeBucket
    Export:
      Name: !Sub '${AWS::StackName}-TechnicalKnowledgeBucket'

  # Lambda Function Outputs
  SupervisorAgentFunctionArn:
    Description: 'Supervisor agent Lambda function ARN'
    Value: !GetAtt SupervisorAgentFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-SupervisorAgentFunctionArn'

  FinanceAgentFunctionArn:
    Description: 'Finance agent Lambda function ARN'
    Value: !GetAtt FinanceAgentFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-FinanceAgentFunctionArn'

  HRAgentFunctionArn:
    Description: 'HR agent Lambda function ARN'
    Value: !GetAtt HRAgentFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-HRAgentFunctionArn'

  TechnicalAgentFunctionArn:
    Description: 'Technical agent Lambda function ARN'
    Value: !GetAtt TechnicalAgentFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-TechnicalAgentFunctionArn'

  # DynamoDB Outputs
  SessionTableName:
    Description: 'DynamoDB session table name'
    Value: !Ref SessionTable
    Export:
      Name: !Sub '${AWS::StackName}-SessionTableName'

  SessionTableArn:
    Description: 'DynamoDB session table ARN'
    Value: !GetAtt SessionTable.Arn
    Export:
      Name: !Sub '${AWS::StackName}-SessionTableArn'

  # IAM Outputs
  AgentCoreExecutionRoleArn:
    Description: 'AgentCore execution role ARN'
    Value: !GetAtt AgentCoreExecutionRole.Arn
    Export:
      Name: !Sub '${AWS::StackName}-AgentCoreExecutionRoleArn'

  # Usage Instructions
  UsageInstructions:
    Description: 'Instructions for testing the multi-agent system'
    Value: !Sub |
      Test the multi-agent knowledge management system:
      
      1. Query endpoint: POST https://${MultiAgentAPI}.execute-api.${AWS::Region}.amazonaws.com/prod/query
      2. Request format: {"query": "your question here", "sessionId": "optional-session-id"}
      3. Health check: GET https://${MultiAgentAPI}.execute-api.${AWS::Region}.amazonaws.com/prod/health
      
      Upload knowledge documents to the S3 buckets:
      - Finance: ${FinanceKnowledgeBucket}
      - HR: ${HRKnowledgeBucket}
      - Technical: ${TechnicalKnowledgeBucket}
      
      Monitor logs in CloudWatch for debugging and performance insights.

  # Cost Estimation
  EstimatedMonthlyCost:
    Description: 'Estimated monthly cost for typical usage'
    Value: !Sub |
      Estimated monthly costs (varies by usage):
      - Lambda: $10-50 (based on invocations and duration)
      - Q Business: $50-200 (based on queries and data sources)
      - DynamoDB: $5-25 (based on read/write requests)
      - S3: $1-10 (based on storage and requests)
      - API Gateway: $3-15 (based on API calls)
      Total estimated range: $69-300/month