/**
 * Automated Event Creation Script for Google Apps Script and Calendar API
 * This script reads event data from Google Sheets and creates calendar events
 * with comprehensive error handling, logging, and notification features.
 * 
 * Generated by Terraform template with configuration:
 * - Sheet ID: ${sheet_id}
 * - Max Events: ${max_events_per_execution}
 * - Debug Logging: ${enable_debug_logging}
 * - Dry Run Mode: ${dry_run_mode}
 */

// Configuration constants
const CONFIG = {
  SHEET_ID: '${sheet_id}',
  NOTIFICATION_EMAIL: '${notification_email}' || Session.getActiveUser().getEmail(),
  MAX_EVENTS_PER_EXECUTION: ${max_events_per_execution},
  EXECUTION_TIMEOUT_SECONDS: ${execution_timeout_seconds},
  ENABLE_DEBUG_LOGGING: ${enable_debug_logging},
  DRY_RUN_MODE: ${dry_run_mode},
  PROJECT_NAME: '${project_name}',
  API_DELAY_MS: 500,
  RETRY_ATTEMPTS: 3,
  RETRY_DELAY_MS: 1000
};

/**
 * Main automation function - entry point for scheduled triggers
 * Orchestrates the complete event creation workflow
 */
function automateEventCreation() {
  const startTime = new Date();
  console.log(`üöÄ Starting ${CONFIG.PROJECT_NAME} automation at ${startTime.toISOString()}`);
  
  try {
    // Validate configuration
    validateConfiguration();
    
    // Read event data from spreadsheet
    const events = readEventData();
    
    if (events.length === 0) {
      logInfo('üìã No events found to process');
      return createExecutionSummary(0, 0, [], startTime);
    }
    
    logInfo(`üìÖ Found ${events.length} events to process (max: ${CONFIG.MAX_EVENTS_PER_EXECUTION})`);
    
    // Limit events to prevent timeout
    const eventsToProcess = events.slice(0, CONFIG.MAX_EVENTS_PER_EXECUTION);
    
    // Process each event with detailed tracking
    const results = processEvents(eventsToProcess);
    
    // Generate and send summary
    const summary = createExecutionSummary(
      results.successCount,
      results.errorCount,
      results.processedEvents,
      startTime
    );
    
    // Send summary email
    sendSummaryEmail(summary);
    
    // Log final results
    console.log(`üéØ Automation complete! Created: ${results.successCount}, Errors: ${results.errorCount}`);
    
    return summary;
    
  } catch (error) {
    logError('üí• Fatal error in automation:', error);
    
    // Send error notification
    sendErrorNotification(error, startTime);
    
    throw error;
  }
}

/**
 * Validates the script configuration and dependencies
 */
function validateConfiguration() {
  logDebug('üîç Validating configuration...');
  
  if (!CONFIG.SHEET_ID) {
    throw new Error('Sheet ID is not configured');
  }
  
  if (!CONFIG.NOTIFICATION_EMAIL) {
    throw new Error('Notification email is not configured');
  }
  
  // Test spreadsheet access
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    if (!spreadsheet) {
      throw new Error('Cannot access spreadsheet');
    }
  } catch (error) {
    throw new Error(`Cannot access spreadsheet: ${error.message}`);
  }
  
  // Test calendar access
  try {
    const calendar = CalendarApp.getDefaultCalendar();
    if (!calendar) {
      throw new Error('Cannot access default calendar');
    }
  } catch (error) {
    throw new Error(`Cannot access calendar: ${error.message}`);
  }
  
  logDebug('‚úÖ Configuration validation passed');
}

/**
 * Reads event data from the Google Sheet
 * @returns {Array} Array of event objects
 */
function readEventData() {
  logDebug('üìñ Reading event data from spreadsheet...');
  
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getActiveSheet();
    
    // Get data range excluding header row
    const lastRow = sheet.getLastRow();
    if (lastRow <= 1) {
      logInfo('üìã No data rows found in spreadsheet');
      return [];
    }
    
    const dataRange = sheet.getRange(2, 1, lastRow - 1, 7);
    const eventData = dataRange.getValues();
    
    // Filter and format event data
    const events = eventData
      .filter(row => row[0] && row[1]) // Must have title and date
      .map((row, index) => ({
        rowNumber: index + 2, // Track original row for logging
        title: String(row[0]).trim(),
        date: parseEventDate(row[1]),
        startTime: String(row[2]).trim(),
        endTime: String(row[3]).trim(),
        description: String(row[4] || '').trim(),
        location: String(row[5] || '').trim(),
        attendees: parseAttendees(row[6])
      }))
      .filter(event => event.date); // Filter out invalid dates
    
    logInfo(`üìä Successfully read ${events.length} valid events from spreadsheet`);
    logDebug(`Event titles: ${events.map(e => e.title).join(', ')}`);
    
    return events;
    
  } catch (error) {
    logError('‚ùå Error reading event data:', error);
    throw new Error(`Failed to read event data: ${error.message}`);
  }
}

/**
 * Processes multiple events with batch handling
 * @param {Array} events - Array of event objects to process
 * @returns {Object} Processing results summary
 */
function processEvents(events) {
  let successCount = 0;
  let errorCount = 0;
  const processedEvents = [];
  
  logInfo(`üîÑ Processing ${events.length} events...`);
  
  events.forEach((eventData, index) => {
    const eventProgress = `${index + 1}/${events.length}`;
    logInfo(`üìÖ Processing event ${eventProgress}: "${eventData.title}"`);
    
    try {
      const result = createCalendarEventWithRetry(eventData);
      
      if (result.success) {
        successCount++;
        processedEvents.push({
          title: eventData.title,
          date: eventData.date.toDateString(),
          status: 'success',
          eventId: result.eventId,
          rowNumber: eventData.rowNumber
        });
        
        logInfo(`‚úÖ Successfully processed "${eventData.title}"`);
      } else {
        errorCount++;
        processedEvents.push({
          title: eventData.title,
          date: eventData.date.toDateString(),
          status: 'error',
          error: result.error,
          rowNumber: eventData.rowNumber
        });
        
        logError(`‚ùå Failed to process "${eventData.title}": ${result.error}`);
      }
      
    } catch (error) {
      errorCount++;
      processedEvents.push({
        title: eventData.title,
        date: eventData.date ? eventData.date.toDateString() : 'Invalid Date',
        status: 'error',
        error: error.message,
        rowNumber: eventData.rowNumber
      });
      
      logError(`üí• Exception processing "${eventData.title}":`, error);
    }
    
    // Add delay between API calls to avoid rate limiting
    if (index < events.length - 1) {
      Utilities.sleep(CONFIG.API_DELAY_MS);
    }
  });
  
  return {
    successCount,
    errorCount,
    processedEvents
  };
}

/**
 * Creates a calendar event with retry logic
 * @param {Object} eventData - Event data object
 * @returns {Object} Result object with success status and details
 */
function createCalendarEventWithRetry(eventData) {
  for (let attempt = 1; attempt <= CONFIG.RETRY_ATTEMPTS; attempt++) {
    try {
      logDebug(`üîÑ Attempt ${attempt}/${CONFIG.RETRY_ATTEMPTS} for event: ${eventData.title}`);
      
      const result = createCalendarEvent(eventData);
      if (result.success) {
        return result;
      }
      
      // If not the last attempt, wait before retrying
      if (attempt < CONFIG.RETRY_ATTEMPTS) {
        logDebug(`‚è≥ Waiting ${CONFIG.RETRY_DELAY_MS}ms before retry...`);
        Utilities.sleep(CONFIG.RETRY_DELAY_MS);
      }
      
    } catch (error) {
      logError(`‚ùå Attempt ${attempt} failed for "${eventData.title}":`, error);
      
      if (attempt === CONFIG.RETRY_ATTEMPTS) {
        return {
          success: false,
          error: `Failed after ${CONFIG.RETRY_ATTEMPTS} attempts: ${error.message}`
        };
      }
      
      // Wait before retrying
      Utilities.sleep(CONFIG.RETRY_DELAY_MS);
    }
  }
  
  return {
    success: false,
    error: `Failed after ${CONFIG.RETRY_ATTEMPTS} attempts`
  };
}

/**
 * Creates a single calendar event
 * @param {Object} eventData - Event data object
 * @returns {Object} Result object with success status and details
 */
function createCalendarEvent(eventData) {
  try {
    // Validate event data
    const validation = validateEventData(eventData);
    if (!validation.isValid) {
      return {
        success: false,
        error: `Invalid event data: ${validation.errors.join(', ')}`
      };
    }
    
    // Parse date and time
    const startDateTime = createDateTime(eventData.date, eventData.startTime);
    const endDateTime = createDateTime(eventData.date, eventData.endTime);
    
    if (!startDateTime || !endDateTime) {
      return {
        success: false,
        error: 'Invalid date/time format'
      };
    }
    
    if (startDateTime >= endDateTime) {
      return {
        success: false,
        error: 'End time must be after start time'
      };
    }
    
    // Check for existing events (duplicate prevention)
    const calendar = CalendarApp.getDefaultCalendar();
    const existingEvents = calendar.getEventsForDay(eventData.date);
    
    const isDuplicate = existingEvents.some(event => 
      event.getTitle() === eventData.title && 
      Math.abs(event.getStartTime().getTime() - startDateTime.getTime()) < 60000 // Within 1 minute
    );
    
    if (isDuplicate) {
      logInfo(`üìã Event "${eventData.title}" already exists, skipping...`);
      return {
        success: true,
        eventId: 'duplicate-skipped',
        message: 'Event already exists'
      };
    }
    
    // Create event in dry-run mode or actual mode
    if (CONFIG.DRY_RUN_MODE) {
      logInfo(`üîç [DRY RUN] Would create event: "${eventData.title}" on ${eventData.date.toDateString()} from ${eventData.startTime} to ${eventData.endTime}`);
      return {
        success: true,
        eventId: 'dry-run-mode',
        message: 'Dry run - event not actually created'
      };
    }
    
    // Create the actual calendar event
    const event = calendar.createEvent(
      eventData.title,
      startDateTime,
      endDateTime,
      {
        description: eventData.description,
        location: eventData.location,
        guests: eventData.attendees.join(','),
        sendInvites: eventData.attendees.length > 0
      }
    );
    
    logInfo(`‚úÖ Created calendar event: "${eventData.title}" (ID: ${event.getId()})`);
    
    return {
      success: true,
      eventId: event.getId(),
      event: event
    };
    
  } catch (error) {
    logError(`‚ùå Error creating event "${eventData.title}":`, error);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Validates event data before processing
 * @param {Object} eventData - Event data to validate
 * @returns {Object} Validation result
 */
function validateEventData(eventData) {
  const errors = [];
  
  if (!eventData.title || eventData.title.length === 0) {
    errors.push('Title is required');
  }
  
  if (!eventData.date || !(eventData.date instanceof Date) || isNaN(eventData.date.getTime())) {
    errors.push('Valid date is required');
  }
  
  if (!eventData.startTime || eventData.startTime.length === 0) {
    errors.push('Start time is required');
  }
  
  if (!eventData.endTime || eventData.endTime.length === 0) {
    errors.push('End time is required');
  }
  
  // Validate time format (basic check)
  if (eventData.startTime && !eventData.startTime.match(/^\d{1,2}:\d{2}$/)) {
    errors.push('Start time must be in HH:MM format');
  }
  
  if (eventData.endTime && !eventData.endTime.match(/^\d{1,2}:\d{2}$/)) {
    errors.push('End time must be in HH:MM format');
  }
  
  return {
    isValid: errors.length === 0,
    errors: errors
  };
}

/**
 * Helper function to parse event dates from various formats
 * @param {*} dateValue - Date value from spreadsheet
 * @returns {Date|null} Parsed date or null if invalid
 */
function parseEventDate(dateValue) {
  try {
    if (dateValue instanceof Date) {
      return new Date(dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate());
    }
    
    if (typeof dateValue === 'string') {
      const parsed = new Date(dateValue);
      if (!isNaN(parsed.getTime())) {
        return new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
      }
    }
    
    // Try parsing common date formats
    const dateStr = String(dateValue);
    const formats = [
      /^\d{4}-\d{2}-\d{2}$/, // YYYY-MM-DD
      /^\d{2}\/\d{2}\/\d{4}$/, // MM/DD/YYYY
      /^\d{2}-\d{2}-\d{4}$/, // MM-DD-YYYY
    ];
    
    for (const format of formats) {
      if (format.test(dateStr)) {
        const parsed = new Date(dateStr);
        if (!isNaN(parsed.getTime())) {
          return new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
        }
      }
    }
    
    logError(`‚ùå Unable to parse date: ${dateValue}`);
    return null;
    
  } catch (error) {
    logError(`‚ùå Error parsing date "${dateValue}":`, error);
    return null;
  }
}

/**
 * Helper function to parse attendee emails
 * @param {*} attendeesValue - Attendees value from spreadsheet
 * @returns {Array} Array of email addresses
 */
function parseAttendees(attendeesValue) {
  if (!attendeesValue) return [];
  
  const attendeesStr = String(attendeesValue).trim();
  if (attendeesStr.length === 0) return [];
  
  return attendeesStr
    .split(/[,;]/)
    .map(email => email.trim())
    .filter(email => email.length > 0 && email.includes('@'));
}

/**
 * Creates a DateTime object from date and time strings
 * @param {Date} date - Date object
 * @param {string} timeStr - Time string in HH:MM format
 * @returns {Date|null} Combined DateTime or null if invalid
 */
function createDateTime(date, timeStr) {
  try {
    const timeParts = timeStr.split(':');
    if (timeParts.length !== 2) return null;
    
    const hours = parseInt(timeParts[0], 10);
    const minutes = parseInt(timeParts[1], 10);
    
    if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
      return null;
    }
    
    const dateTime = new Date(date);
    dateTime.setHours(hours, minutes, 0, 0);
    
    return dateTime;
    
  } catch (error) {
    logError(`‚ùå Error creating DateTime from "${date}" and "${timeStr}":`, error);
    return null;
  }
}

/**
 * Creates an execution summary object
 * @param {number} successCount - Number of successful events
 * @param {number} errorCount - Number of failed events
 * @param {Array} processedEvents - Array of processed event details
 * @param {Date} startTime - Execution start time
 * @returns {Object} Summary object
 */
function createExecutionSummary(successCount, errorCount, processedEvents, startTime) {
  const endTime = new Date();
  const duration = Math.round((endTime.getTime() - startTime.getTime()) / 1000);
  
  return {
    executionTime: endTime.toISOString(),
    startTime: startTime.toISOString(),
    duration: `${duration} seconds`,
    totalEvents: processedEvents.length,
    successCount: successCount,
    errorCount: errorCount,
    successRate: processedEvents.length > 0 ? Math.round((successCount / processedEvents.length) * 100) : 0,
    processedEvents: processedEvents,
    configuration: {
      dryRunMode: CONFIG.DRY_RUN_MODE,
      maxEventsPerExecution: CONFIG.MAX_EVENTS_PER_EXECUTION,
      debugLogging: CONFIG.ENABLE_DEBUG_LOGGING
    }
  };
}

/**
 * Sends a comprehensive summary email
 * @param {Object} summary - Execution summary object
 */
function sendSummaryEmail(summary) {
  try {
    const subject = `üìÖ ${CONFIG.PROJECT_NAME} - Execution Summary (${summary.successCount}/${summary.totalEvents} successful)`;
    
    const successEvents = summary.processedEvents.filter(event => event.status === 'success');
    const errorEvents = summary.processedEvents.filter(event => event.status === 'error');
    
    const body = `
${CONFIG.PROJECT_NAME} - Automation Summary
${'='.repeat(50)}

Execution Details:
‚Ä¢ Start Time: ${summary.startTime}
‚Ä¢ End Time: ${summary.executionTime}
‚Ä¢ Duration: ${summary.duration}
‚Ä¢ Mode: ${CONFIG.DRY_RUN_MODE ? 'DRY RUN' : 'PRODUCTION'}

Results:
‚Ä¢ Total Events Processed: ${summary.totalEvents}
‚Ä¢ Events Created Successfully: ${summary.successCount}
‚Ä¢ Events with Errors: ${summary.errorCount}
‚Ä¢ Success Rate: ${summary.successRate}%

${summary.successCount > 0 ? `
‚úÖ Successfully Created Events:
${successEvents.map(event => `   ‚Ä¢ ${event.title} (${event.date}) [Row ${event.rowNumber}]`).join('\n')}
` : ''}

${summary.errorCount > 0 ? `
‚ùå Events with Errors:
${errorEvents.map(event => `   ‚Ä¢ ${event.title} (${event.date}) - ${event.error} [Row ${event.rowNumber}]`).join('\n')}

Please check the spreadsheet data and try again for failed events.
` : ''}

${summary.totalEvents === 0 ? '‚ÑπÔ∏è No events found in the spreadsheet to process.' : ''}

Configuration:
‚Ä¢ Max Events per Execution: ${CONFIG.MAX_EVENTS_PER_EXECUTION}
‚Ä¢ Debug Logging: ${CONFIG.ENABLE_DEBUG_LOGGING ? 'Enabled' : 'Disabled'}
‚Ä¢ Dry Run Mode: ${CONFIG.DRY_RUN_MODE ? 'Enabled' : 'Disabled'}

Resources:
‚Ä¢ Google Sheet: https://docs.google.com/spreadsheets/d/${CONFIG.SHEET_ID}/edit
‚Ä¢ Apps Script: https://script.google.com/
‚Ä¢ Calendar: https://calendar.google.com/

This is an automated message from ${CONFIG.PROJECT_NAME}.
For detailed logs, check the Apps Script execution transcript.
    `;
    
    GmailApp.sendEmail(CONFIG.NOTIFICATION_EMAIL, subject, body);
    logInfo(`üìß Summary email sent to ${CONFIG.NOTIFICATION_EMAIL}`);
    
  } catch (error) {
    logError('üìß Error sending summary email:', error);
  }
}

/**
 * Sends error notification email
 * @param {Error} error - Error object
 * @param {Date} startTime - Execution start time
 */
function sendErrorNotification(error, startTime) {
  try {
    const subject = `üö® ${CONFIG.PROJECT_NAME} - Automation Error`;
    
    const body = `
${CONFIG.PROJECT_NAME} - ERROR NOTIFICATION
${'='.repeat(50)}

A critical error occurred during automation execution:

Error Details:
‚Ä¢ Time: ${new Date().toISOString()}
‚Ä¢ Start Time: ${startTime.toISOString()}
‚Ä¢ Error Message: ${error.message}
‚Ä¢ Error Stack: ${error.stack || 'No stack trace available'}

Configuration:
‚Ä¢ Sheet ID: ${CONFIG.SHEET_ID}
‚Ä¢ Project: ${CONFIG.PROJECT_NAME}
‚Ä¢ Dry Run Mode: ${CONFIG.DRY_RUN_MODE}

Action Required:
1. Check the Google Apps Script execution logs
2. Verify spreadsheet data and permissions
3. Ensure Calendar API access is working
4. Review error details above

Resources:
‚Ä¢ Google Sheet: https://docs.google.com/spreadsheets/d/${CONFIG.SHEET_ID}/edit
‚Ä¢ Apps Script: https://script.google.com/
‚Ä¢ Execution Logs: Check the Apps Script editor console

This is an automated error notification from ${CONFIG.PROJECT_NAME}.
    `;
    
    GmailApp.sendEmail(CONFIG.NOTIFICATION_EMAIL, subject, body);
    logError(`üö® Error notification sent to ${CONFIG.NOTIFICATION_EMAIL}`);
    
  } catch (emailError) {
    logError('üìß Failed to send error notification:', emailError);
  }
}

// Logging utility functions
function logInfo(message) {
  console.log(`[INFO] ${message}`);
}

function logError(message, error) {
  const errorMsg = error ? `${message} ${error.toString()}` : message;
  console.error(`[ERROR] ${errorMsg}`);
}

function logDebug(message) {
  if (CONFIG.ENABLE_DEBUG_LOGGING) {
    console.log(`[DEBUG] ${message}`);
  }
}

// Trigger management functions
function createDailyTrigger() {
  try {
    // Delete existing triggers to avoid duplicates
    deleteExistingTriggers();
    
    // Create new daily trigger
    const trigger = ScriptApp.newTrigger('automateEventCreation')
      .timeBased()
      .everyDays(1)
      .atHour(8) // 8 AM
      .create();
    
    logInfo(`‚è∞ Daily trigger created successfully (ID: ${trigger.getUniqueId()})`);
    return trigger;
    
  } catch (error) {
    logError('‚è∞ Error creating trigger:', error);
    throw error;
  }
}

function deleteExistingTriggers() {
  try {
    const existingTriggers = ScriptApp.getProjectTriggers();
    let deletedCount = 0;
    
    existingTriggers.forEach(trigger => {
      if (trigger.getHandlerFunction() === 'automateEventCreation') {
        ScriptApp.deleteTrigger(trigger);
        deletedCount++;
        logInfo(`üóëÔ∏è Removed existing trigger: ${trigger.getUniqueId()}`);
      }
    });
    
    logInfo(`üßπ Cleanup complete: ${deletedCount} triggers removed`);
    
  } catch (error) {
    logError('üóëÔ∏è Error deleting existing triggers:', error);
  }
}

// Test and utility functions
function testEventReading() {
  logInfo('üß™ Testing event data reading...');
  
  try {
    const events = readEventData();
    logInfo(`üìä Test result: ${events.length} events read successfully`);
    
    if (events.length > 0) {
      logInfo('Sample event data:');
      logInfo(JSON.stringify(events[0], null, 2));
    }
    
    return events;
    
  } catch (error) {
    logError('‚ùå Event reading test failed:', error);
    throw error;
  }
}

function testSingleEvent() {
  logInfo('üß™ Testing single event creation...');
  
  const testEvent = {
    title: 'Test Event - Automation Check',
    date: new Date(),
    startTime: '10:00',
    endTime: '11:00',
    description: 'Testing automation system',
    location: 'Test Location',
    attendees: []
  };
  
  try {
    const result = createCalendarEvent(testEvent);
    logInfo(`Test result: ${result.success ? '‚úÖ Success' : '‚ùå Failed'}`);
    
    if (!result.success) {
      logError('Test error:', result.error);
    }
    
    return result;
    
  } catch (error) {
    logError('‚ùå Single event test failed:', error);
    throw error;
  }
}

function getConfigInfo() {
  logInfo('‚ÑπÔ∏è Configuration Information:');
  logInfo(`Sheet ID: ${CONFIG.SHEET_ID}`);
  logInfo(`Notification Email: ${CONFIG.NOTIFICATION_EMAIL}`);
  logInfo(`Max Events: ${CONFIG.MAX_EVENTS_PER_EXECUTION}`);
  logInfo(`Timeout: ${CONFIG.EXECUTION_TIMEOUT_SECONDS}s`);
  logInfo(`Debug Logging: ${CONFIG.ENABLE_DEBUG_LOGGING}`);
  logInfo(`Dry Run Mode: ${CONFIG.DRY_RUN_MODE}`);
  
  return CONFIG;
}