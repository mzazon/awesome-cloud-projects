# =============================================================================
# Weather API with Cloud Functions - Terraform Variables Example
# =============================================================================
# Copy this file to terraform.tfvars and customize the values for your
# deployment. This file shows all available configuration options with
# example values and explanations.
# =============================================================================

# =============================================================================
# REQUIRED VARIABLES
# =============================================================================
# These variables must be set for the deployment to work

# Google Cloud project ID where resources will be created
# Replace with your actual project ID
project_id = "weather-api-demo-123456"

# =============================================================================
# BASIC CONFIGURATION
# =============================================================================

# Google Cloud region for deploying resources
# Choose a region close to your users for better performance
region = "us-central1"
# Other popular options: "us-east1", "europe-west1", "asia-east1"

# Environment name for resource labeling and organization
environment = "development"
# Options: "development", "staging", "production"

# =============================================================================
# CLOUD FUNCTION CONFIGURATION
# =============================================================================

# Name of the Cloud Function for the weather API
# Must be lowercase with hyphens, 1-63 characters
function_name = "weather-api"

# Runtime environment for the Cloud Function
# Choose the Python version that matches your development environment
function_runtime = "python313"
# Other options: "python312", "python311", "python310"

# The name of the function to execute (matches the @functions_framework.http decorator)
function_entry_point = "weather_api"

# =============================================================================
# PERFORMANCE AND SCALING CONFIGURATION
# =============================================================================

# Amount of memory allocated to the Cloud Function
# More memory = better performance but higher cost
memory_mb = "256M"
# Options: "128M", "256M", "512M", "1024M", "2048M", "4096M", "8192M"

# Maximum execution time for the Cloud Function (in seconds)
# Weather API should respond quickly, 60 seconds is generous
timeout_seconds = 60

# Maximum number of function instances that can run concurrently
# Adjust based on expected traffic
max_instance_count = 100

# Minimum number of function instances to keep warm
# Set to 0 for true serverless (cold starts) or higher to reduce latency
min_instance_count = 0

# =============================================================================
# ENVIRONMENT VARIABLES FOR THE FUNCTION
# =============================================================================

# Environment variables passed to the Cloud Function
environment_variables = {
  FUNCTION_SIGNATURE_TYPE = "http"
  FUNCTION_TARGET         = "weather_api"
  LOG_LEVEL              = "INFO"
  WEATHER_API_VERSION    = "1.0"
}

# API key for external weather service (leave empty for mock data)
# Set this if you plan to integrate with real weather services
weather_api_key = ""

# =============================================================================
# MONITORING AND OBSERVABILITY
# =============================================================================

# Enable monitoring and log-based metrics for the function
# Recommended for production deployments
enable_monitoring = true

# Logging level for the Cloud Function
# DEBUG for development, INFO for production
log_level = "INFO"

# =============================================================================
# SECURITY CONFIGURATION
# =============================================================================

# Allow unauthenticated access to the Cloud Function
# Set to true for public APIs, false for internal use
allow_unauthenticated = true

# List of allowed origins for CORS (Cross-Origin Resource Sharing)
# Use ["*"] for development, specific domains for production
cors_origins = ["*"]
# Production example: ["https://myapp.com", "https://www.myapp.com"]

# Ingress settings for the Cloud Function
# ALLOW_ALL: Accept requests from anywhere
# ALLOW_INTERNAL_ONLY: Only from GCP resources
# ALLOW_INTERNAL_AND_GCLB: Internal + Google Cloud Load Balancer
ingress_settings = "ALLOW_ALL"

# =============================================================================
# RESOURCE TAGGING AND ORGANIZATION
# =============================================================================

# Additional labels to apply to all resources
# Use for cost tracking, team ownership, etc.
labels = {
  team        = "platform"
  project     = "weather-service"
  cost_center = "engineering"
  owner       = "devops-team"
}

# Cost center identifier for billing and resource tracking
cost_center = "engineering"

# Owner or team responsible for this deployment
owner = "platform-team"

# =============================================================================
# ADVANCED CONFIGURATION
# =============================================================================

# Custom service account email (if not provided, one will be created)
# Leave empty to create a new service account with minimal permissions
service_account_email = ""

# VPC connector name for private network access (optional)
# Only needed if your function needs to access resources in a VPC
vpc_connector = ""

# Custom name for the source code storage bucket
# Leave empty for auto-generated name
source_bucket_name = ""

# Number of days to retain source code archives in Cloud Storage
source_archive_retention_days = 30

# =============================================================================
# DEVELOPMENT vs PRODUCTION EXAMPLES
# =============================================================================

# DEVELOPMENT CONFIGURATION EXAMPLE:
# environment = "development"
# memory_mb = "256M"
# max_instance_count = 10
# min_instance_count = 0
# allow_unauthenticated = true
# cors_origins = ["*"]
# enable_monitoring = true
# log_level = "DEBUG"

# STAGING CONFIGURATION EXAMPLE:
# environment = "staging"
# memory_mb = "512M"
# max_instance_count = 50
# min_instance_count = 1
# allow_unauthenticated = true
# cors_origins = ["https://staging.myapp.com"]
# enable_monitoring = true
# log_level = "INFO"

# PRODUCTION CONFIGURATION EXAMPLE:
# environment = "production"
# memory_mb = "512M"
# max_instance_count = 200
# min_instance_count = 2
# allow_unauthenticated = true
# cors_origins = ["https://myapp.com", "https://www.myapp.com"]
# enable_monitoring = true
# log_level = "INFO"
# weather_api_key = "your-production-api-key"

# =============================================================================
# MULTI-REGION DEPLOYMENT EXAMPLE
# =============================================================================
# For global applications, consider deploying to multiple regions:

# PRIMARY REGION (US):
# region = "us-central1"
# function_name = "weather-api-us"

# SECONDARY REGION (EU):
# region = "europe-west1" 
# function_name = "weather-api-eu"

# SECONDARY REGION (ASIA):
# region = "asia-east1"
# function_name = "weather-api-asia"

# =============================================================================
# SECURITY BEST PRACTICES
# =============================================================================

# For production deployments:
# 1. Set allow_unauthenticated = false and implement proper authentication
# 2. Use specific CORS origins instead of "*"
# 3. Set ingress_settings = "ALLOW_INTERNAL_AND_GCLB" if using load balancer
# 4. Store sensitive data like API keys in Secret Manager
# 5. Enable audit logging and monitoring
# 6. Use least privilege IAM roles
# 7. Regularly update runtime versions and dependencies

# =============================================================================
# COST OPTIMIZATION TIPS
# =============================================================================

# To minimize costs:
# 1. Set min_instance_count = 0 for true serverless pricing
# 2. Use appropriate memory allocation (don't over-provision)
# 3. Set reasonable timeout_seconds to avoid runaway functions
# 4. Monitor usage with enable_monitoring = true
# 5. Use lifecycle policies on storage buckets
# 6. Consider regional deployment vs multi-region based on needs