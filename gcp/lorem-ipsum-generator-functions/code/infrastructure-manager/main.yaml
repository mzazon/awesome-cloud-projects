# Google Cloud Infrastructure Manager Configuration
# Lorem Ipsum Generator with Cloud Functions and Cloud Storage
# 
# This configuration deploys a complete serverless lorem ipsum text generation API
# using Google Cloud Functions (2nd generation) with Cloud Storage caching.
# 
# Architecture:
# - Cloud Functions (Gen2) for serverless API endpoint
# - Cloud Storage bucket for text caching and performance optimization
# - IAM service account with least privilege access
# - Required APIs and services enabled

# Variables for customization
variables:
  project_id:
    description: "Google Cloud Project ID where resources will be created"
    type: string
  
  region:
    description: "Google Cloud region for deployment (e.g., us-central1)"
    type: string
    default: "us-central1"
  
  environment:
    description: "Environment label for resource naming (e.g., dev, staging, prod)"
    type: string
    default: "dev"
  
  function_memory:
    description: "Memory allocation for Cloud Function in MB"
    type: string
    default: "256Mi"
  
  function_timeout:
    description: "Timeout for Cloud Function execution in seconds"
    type: number
    default: 60

# Local values for consistent naming and configuration
locals:
  # Generate unique suffix for global resources to avoid naming conflicts
  random_suffix: "${random_id.deployment_id.hex}"
  
  # Consistent resource naming convention
  resource_prefix: "lorem-ipsum-${var.environment}"
  
  # Labels applied to all resources for governance and cost tracking
  common_labels: {
    environment: "${var.environment}"
    application: "lorem-ipsum-generator"
    managed-by: "infrastructure-manager"
    cost-center: "development"
  }

# Generate random ID for unique resource naming
resource "random_id" "deployment_id" {
  byte_length = 3
}

# Enable required Google Cloud APIs
resource "google_project_service" "required_apis" {
  for_each = toset([
    "cloudfunctions.googleapis.com",    # Cloud Functions API
    "storage.googleapis.com",           # Cloud Storage API  
    "cloudbuild.googleapis.com",        # Cloud Build API (required for function deployment)
    "secretmanager.googleapis.com",     # Secret Manager API (best practice for configuration)
    "logging.googleapis.com",           # Cloud Logging API
    "monitoring.googleapis.com"         # Cloud Monitoring API
  ])
  
  project = var.project_id
  service = each.value
  
  # Prevent accidental API disabling during resource destruction
  disable_dependent_services = false
  disable_on_destroy = false
}

# IAM Service Account for Cloud Function
# Follows principle of least privilege with minimal required permissions
resource "google_service_account" "function_service_account" {
  project      = var.project_id
  account_id   = "${local.resource_prefix}-sa-${local.random_suffix}"
  display_name = "Lorem Ipsum Generator Function Service Account"
  description  = "Service account for Cloud Function with minimal required permissions"
  
  depends_on = [google_project_service.required_apis]
}

# Cloud Storage bucket for lorem ipsum text caching
# Configured with versioning and lifecycle management for optimal performance
resource "google_storage_bucket" "lorem_cache_bucket" {
  project  = var.project_id
  name     = "${local.resource_prefix}-cache-${local.random_suffix}"
  location = var.region
  
  # Storage class optimized for frequent access patterns
  storage_class = "STANDARD"
  
  # Enable versioning for data protection and rollback capabilities
  versioning {
    enabled = true
  }
  
  # Lifecycle management to optimize storage costs
  lifecycle_rule {
    condition {
      age = 30  # Archive versions older than 30 days
    }
    action {
      type = "SetStorageClass"
      storage_class = "NEARLINE"
    }
  }
  
  lifecycle_rule {
    condition {
      age = 90  # Delete versions older than 90 days
    }
    action {
      type = "Delete"
    }
  }
  
  # Security: Prevent public access
  public_access_prevention = "enforced"
  uniform_bucket_level_access = true
  
  # Apply consistent labeling
  labels = local.common_labels
  
  depends_on = [google_project_service.required_apis]
}

# IAM binding for function service account to access storage bucket
resource "google_storage_bucket_iam_member" "function_storage_access" {
  bucket = google_storage_bucket.lorem_cache_bucket.name
  role   = "roles/storage.objectAdmin"
  member = "serviceAccount:${google_service_account.function_service_account.email}"
  
  depends_on = [
    google_storage_bucket.lorem_cache_bucket,
    google_service_account.function_service_account
  ]
}

# Create function source code archive
# This archive contains the Python source code for the lorem ipsum generator
data "archive_file" "function_source" {
  type        = "zip"
  output_path = "/tmp/lorem-function-source.zip"
  
  source {
    content = <<-EOT
import json
import random
import hashlib
from google.cloud import storage
import functions_framework

# Lorem ipsum word bank for text generation
LOREM_WORDS = [
    "lorem", "ipsum", "dolor", "sit", "amet", "consectetur", "adipiscing", "elit",
    "sed", "do", "eiusmod", "tempor", "incididunt", "ut", "labore", "et", "dolore",
    "magna", "aliqua", "enim", "ad", "minim", "veniam", "quis", "nostrud",
    "exercitation", "ullamco", "laboris", "nisi", "aliquip", "ex", "ea", "commodo",
    "consequat", "duis", "aute", "irure", "in", "reprehenderit", "voluptate",
    "velit", "esse", "cillum", "fugiat", "nulla", "pariatur", "excepteur", "sint",
    "occaecat", "cupidatat", "non", "proident", "sunt", "culpa", "qui", "officia",
    "deserunt", "mollit", "anim", "id", "est", "laborum"
]

def get_cached_text(cache_key, bucket_name):
    """Retrieve cached lorem ipsum text from Cloud Storage"""
    try:
        client = storage.Client()
        bucket = client.bucket(bucket_name)
        blob = bucket.blob(f"cache/{cache_key}.txt")
        
        if blob.exists():
            return blob.download_as_text()
    except Exception as e:
        print(f"Cache retrieval error: {e}")
    return None

def cache_text(cache_key, text, bucket_name):
    """Store generated lorem ipsum text in Cloud Storage cache"""
    try:
        client = storage.Client()
        bucket = client.bucket(bucket_name)
        blob = bucket.blob(f"cache/{cache_key}.txt")
        blob.upload_from_string(text)
    except Exception as e:
        print(f"Cache storage error: {e}")

def generate_lorem_text(paragraphs=3, words_per_paragraph=50):
    """Generate lorem ipsum text with specified parameters"""
    result_paragraphs = []
    
    for _ in range(paragraphs):
        # Generate words for this paragraph
        paragraph_words = []
        for i in range(words_per_paragraph):
            word = random.choice(LOREM_WORDS)
            # Capitalize first word of paragraph
            if i == 0:
                word = word.capitalize()
            paragraph_words.append(word)
        
        # Join words and add period at end
        paragraph = " ".join(paragraph_words) + "."
        result_paragraphs.append(paragraph)
    
    return "\n\n".join(result_paragraphs)

@functions_framework.http
def lorem_generator(request):
    """HTTP Cloud Function entry point for lorem ipsum generation"""
    # Set CORS headers for web browser access
    headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Content-Type': 'application/json'
    }
    
    # Handle preflight OPTIONS request
    if request.method == 'OPTIONS':
        return ('', 204, headers)
    
    try:
        # Parse query parameters with defaults
        paragraphs = int(request.args.get('paragraphs', 3))
        words_per_paragraph = int(request.args.get('words', 50))
        
        # Validate parameters
        paragraphs = max(1, min(paragraphs, 10))  # Limit 1-10 paragraphs
        words_per_paragraph = max(10, min(words_per_paragraph, 200))  # Limit 10-200 words
        
        # Generate cache key from parameters
        cache_key = hashlib.md5(f"{paragraphs}-{words_per_paragraph}".encode()).hexdigest()
        bucket_name = "${google_storage_bucket.lorem_cache_bucket.name}"
        
        # Try to get cached text first
        cached_text = get_cached_text(cache_key, bucket_name)
        if cached_text:
            response_data = {
                "text": cached_text,
                "paragraphs": paragraphs,
                "words_per_paragraph": words_per_paragraph,
                "cached": True
            }
        else:
            # Generate new text
            lorem_text = generate_lorem_text(paragraphs, words_per_paragraph)
            
            # Cache the generated text
            cache_text(cache_key, lorem_text, bucket_name)
            
            response_data = {
                "text": lorem_text,
                "paragraphs": paragraphs,
                "words_per_paragraph": words_per_paragraph,
                "cached": False
            }
        
        return (json.dumps(response_data), 200, headers)
    
    except Exception as e:
        error_response = {
            "error": "Failed to generate lorem ipsum text",
            "message": str(e)
        }
        return (json.dumps(error_response), 500, headers)
EOT
    filename = "main.py"
  }
  
  source {
    content = <<-EOT
functions-framework==3.8.*
google-cloud-storage==2.17.*
EOT
    filename = "requirements.txt"
  }
}

# Upload function source code to storage bucket for deployment
resource "google_storage_bucket_object" "function_source" {
  name   = "function-source-${local.random_suffix}.zip"
  bucket = google_storage_bucket.lorem_cache_bucket.name
  source = data.archive_file.function_source.output_path
  
  depends_on = [
    google_storage_bucket.lorem_cache_bucket,
    data.archive_file.function_source
  ]
}

# Cloud Function (Generation 2) for serverless lorem ipsum API
# Configured with optimal settings for performance and cost efficiency
resource "google_cloudfunctions2_function" "lorem_generator" {
  project     = var.project_id
  name        = "${local.resource_prefix}-function-${local.random_suffix}"
  location    = var.region
  description = "Serverless lorem ipsum text generation API with caching"
  
  # Build configuration for function deployment
  build_config {
    runtime     = "python312"
    entry_point = "lorem_generator"
    
    source {
      storage_source {
        bucket = google_storage_bucket.lorem_cache_bucket.name
        object = google_storage_bucket_object.function_source.name
      }
    }
  }
  
  # Service configuration for runtime behavior
  service_config {
    max_instance_count               = 100    # Scale up to handle traffic spikes
    min_instance_count               = 0      # Scale to zero for cost optimization
    available_memory                 = var.function_memory
    timeout_seconds                  = var.function_timeout
    max_instance_request_concurrency = 80     # Handle multiple requests per instance
    available_cpu                    = "1"    # CPU allocation
    
    # Environment variables for function configuration
    environment_variables = {
      CACHE_BUCKET = google_storage_bucket.lorem_cache_bucket.name
      ENVIRONMENT  = var.environment
    }
    
    # Security: Use custom service account with minimal permissions
    service_account_email = google_service_account.function_service_account.email
    
    # Ingress control: Allow all traffic for public API access
    ingress_settings = "ALLOW_ALL"
    
    # Security: Enable all outbound traffic for Cloud Storage access
    all_traffic_on_latest_revision = true
  }
  
  # Apply consistent labeling for governance
  labels = local.common_labels
  
  depends_on = [
    google_project_service.required_apis,
    google_storage_bucket_object.function_source,
    google_service_account.function_service_account,
    google_storage_bucket_iam_member.function_storage_access
  ]
}

# IAM policy to allow public unauthenticated access to the function
# This enables the function to serve as a public API endpoint
resource "google_cloudfunctions2_function_iam_member" "public_access" {
  project        = var.project_id
  location       = google_cloudfunctions2_function.lorem_generator.location
  cloud_function = google_cloudfunctions2_function.lorem_generator.name
  role           = "roles/cloudfunctions.invoker"
  member         = "allUsers"
  
  depends_on = [google_cloudfunctions2_function.lorem_generator]
}

# Outputs for integration and verification
outputs:
  function_url:
    description: "HTTPS URL of the deployed lorem ipsum generator function"
    value: google_cloudfunctions2_function.lorem_generator.service_config[0].uri
  
  function_name:
    description: "Name of the deployed Cloud Function"
    value: google_cloudfunctions2_function.lorem_generator.name
  
  storage_bucket_name:
    description: "Name of the Cloud Storage bucket used for caching"
    value: google_storage_bucket.lorem_cache_bucket.name
  
  service_account_email:
    description: "Email of the service account used by the function"
    value: google_service_account.function_service_account.email
  
  deployment_region:
    description: "Google Cloud region where resources are deployed"
    value: var.region
  
  sample_api_calls:
    description: "Example API calls to test the deployed function"
    value: {
      basic_request = "${google_cloudfunctions2_function.lorem_generator.service_config[0].uri}?paragraphs=3&words=50"
      minimal_request = "${google_cloudfunctions2_function.lorem_generator.service_config[0].uri}?paragraphs=1&words=10"
      maximum_request = "${google_cloudfunctions2_function.lorem_generator.service_config[0].uri}?paragraphs=5&words=100"
    }
  
  cost_optimization_notes:
    description: "Cost optimization features enabled in this deployment"
    value: {
      function_scaling = "Scales to zero when not in use"
      storage_lifecycle = "Automatic archival of old cached content"
      memory_allocation = "Optimized ${var.function_memory} memory allocation"
      api_usage = "Free tier: 2M invocations/month, 5GB storage/month"
    }

# Terraform provider requirements
terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 6.0"
    }
    archive = {
      source  = "hashicorp/archive"
      version = "~> 2.4"
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.6"
    }
  }
  required_version = ">= 1.5"
}