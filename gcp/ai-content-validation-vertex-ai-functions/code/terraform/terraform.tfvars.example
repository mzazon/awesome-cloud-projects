# Example Terraform Variables Configuration
# Copy this file to terraform.tfvars and customize for your deployment
# This file provides example values for all configurable variables

# REQUIRED VARIABLES
# These must be configured for your specific deployment

# Your Google Cloud Project ID
project_id = "my-content-validation-project"

# Primary region for deployment (choose based on your location and Vertex AI availability)
region = "us-central1"

# Availability zone (should be in the same region)
zone = "us-central1-a"

# ENVIRONMENT CONFIGURATION
# Customize based on your deployment environment

# Environment name (affects resource naming and tagging)
environment = "production"

# STORAGE CONFIGURATION
# Configure Cloud Storage buckets according to your needs

# Storage class for content input bucket (STANDARD, NEARLINE, COLDLINE, ARCHIVE)
content_bucket_location = "STANDARD"

# Storage class for validation results bucket
results_bucket_location = "STANDARD"

# Enable bucket versioning for data protection
bucket_versioning_enabled = true

# Enable automatic lifecycle management
bucket_lifecycle_enabled = true

# Days after which to move objects to cheaper storage
bucket_lifecycle_age_days = 30

# Days to retain validation results before deletion
bucket_retention_days = 90

# CLOUD FUNCTION CONFIGURATION
# Adjust based on your performance and cost requirements

# Python runtime version
function_runtime = "python312"

# Memory allocation (128Mi, 256Mi, 512Mi, 1Gi, 2Gi, 4Gi, 8Gi)
function_memory = "512Mi"

# Maximum execution time in seconds (1-540)
function_timeout = 60

# Minimum instances to keep warm (0-10)
function_min_instances = 0

# Maximum instances for scaling (1-100)
function_max_instances = 10

# Concurrent requests per instance (1-1000)
function_concurrency = 1

# Enable CPU boost for better cold start performance
enable_function_cpu_boost = false

# VERTEX AI CONFIGURATION
# Configure AI model and safety settings

# Region for Vertex AI operations (must support Gemini models)
vertex_ai_location = "us-central1"

# Gemini model to use for validation
gemini_model_name = "gemini-1.5-flash"

# Safety threshold for content blocking
# Options: BLOCK_NONE, BLOCK_LOW_AND_ABOVE, BLOCK_MEDIUM_AND_ABOVE, BLOCK_ONLY_HIGH
safety_threshold = "BLOCK_MEDIUM_AND_ABOVE"

# SECURITY CONFIGURATION
# Configure access controls and security features

# Enable uniform bucket-level access for enhanced security
enable_uniform_bucket_level_access = true

# Prevent public access to storage buckets
enable_public_access_prevention = true

# List of email addresses or service accounts allowed to invoke the function
allowed_principals = [
  # "user@example.com",
  # "serviceAccount:my-app@my-project.iam.gserviceaccount.com"
]

# Enable VPC connector for private networking (requires existing connector)
enable_vpc_connector = false

# VPC connector name (if enable_vpc_connector is true)
# vpc_connector_name = "projects/my-project/locations/us-central1/connectors/my-connector"

# MONITORING AND LOGGING
# Configure observability features

# Enable Cloud Monitoring alerts
enable_monitoring = true

# Enable enhanced Cloud Logging
enable_cloud_logging = true

# Function log level (DEBUG, INFO, WARNING, ERROR)
log_level = "INFO"

# Notification channels for alerts (requires pre-created channels)
monitoring_notification_channels = [
  # "projects/my-project/notificationChannels/CHANNEL_ID_1",
  # "projects/my-project/notificationChannels/CHANNEL_ID_2"
]

# PERFORMANCE OPTIMIZATION
# Configure for high-performance or cost-optimized scenarios

# Enable request payer for cost optimization
enable_bucket_request_payer = false

# Random suffix length for resource naming (4-8)
random_suffix_length = 6

# API CONFIGURATION
# Additional Google Cloud APIs to enable

enable_apis = [
  # "compute.googleapis.com",
  # "dns.googleapis.com"
]

# Whether to disable dependent services when destroying
disable_dependent_services = false

# RESOURCE LABELING
# Apply custom labels to all resources for organization and cost tracking

labels = {
  # Organization labels
  team         = "ai-engineering"
  department   = "engineering"
  cost-center  = "engineering-ai"
  
  # Project labels
  project      = "content-validation"
  application  = "ai-safety-validation"
  component    = "content-processor"
  
  # Environment labels
  environment  = "production"
  
  # Lifecycle labels
  managed-by   = "terraform"
  created-by   = "deployment-pipeline"
  
  # Business labels
  business-unit = "product"
  owner        = "ai-team"
  
  # Compliance labels
  data-classification = "internal"
  backup-required     = "true"
  monitoring-required = "true"
}

# DEVELOPMENT ENVIRONMENT EXAMPLE
# Uncomment and modify for development/testing environments

# # Development-specific overrides
# environment = "dev"
# function_memory = "256Mi"
# function_max_instances = 3
# bucket_retention_days = 7
# safety_threshold = "BLOCK_LOW_AND_ABOVE"
# log_level = "DEBUG"

# STAGING ENVIRONMENT EXAMPLE
# Uncomment and modify for staging environments

# # Staging-specific overrides
# environment = "staging"
# function_memory = "512Mi"
# function_max_instances = 5
# bucket_retention_days = 30
# enable_function_cpu_boost = true

# HIGH-PERFORMANCE CONFIGURATION EXAMPLE
# Uncomment for high-throughput scenarios

# # High-performance overrides
# function_memory = "1Gi"
# function_timeout = 120
# function_max_instances = 50
# function_min_instances = 2
# function_concurrency = 10
# enable_function_cpu_boost = true

# COST-OPTIMIZED CONFIGURATION EXAMPLE  
# Uncomment for cost-sensitive deployments

# # Cost optimization overrides
# content_bucket_location = "NEARLINE"
# results_bucket_location = "COLDLINE"
# bucket_lifecycle_age_days = 7
# bucket_retention_days = 30
# function_memory = "256Mi"
# function_max_instances = 3