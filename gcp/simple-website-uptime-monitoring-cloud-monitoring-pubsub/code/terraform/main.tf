# Main Terraform configuration for GCP website uptime monitoring
# This configuration creates a complete uptime monitoring solution using
# Cloud Monitoring, Pub/Sub, and Cloud Functions

# Generate random suffix for unique resource names
resource "random_id" "suffix" {
  byte_length = 3
}

locals {
  # Common resource naming and labeling
  resource_suffix = random_id.suffix.hex
  common_labels = merge(var.labels, {
    terraform-managed = "true"
    created-date     = formatdate("YYYY-MM-DD", timestamp())
  })
  
  # Extract hostnames from website URLs for resource naming
  website_hostnames = [
    for url in var.websites_to_monitor :
    replace(replace(url, "https://", ""), "http://", "")
  ]
}

# Enable required Google Cloud APIs
resource "google_project_service" "required_apis" {
  for_each = toset([
    "monitoring.googleapis.com",
    "pubsub.googleapis.com", 
    "cloudfunctions.googleapis.com",
    "cloudbuild.googleapis.com",
    "cloudresourcemanager.googleapis.com"
  ])
  
  service = each.value
  
  # Prevent deletion of APIs to avoid disruption
  disable_dependent_services = false
  disable_on_destroy         = false
}

# Create Pub/Sub topic for alert distribution
resource "google_pubsub_topic" "uptime_alerts" {
  name = "${var.resource_prefix}-alerts-${local.resource_suffix}"
  
  labels = local.common_labels
  
  # Enable message storage for improved reliability
  message_storage_policy {
    allowed_persistence_regions = [var.region]
  }
  
  depends_on = [google_project_service.required_apis]
}

# Create Cloud Storage bucket for Cloud Function source code
resource "google_storage_bucket" "function_source" {
  name          = "${var.project_id}-function-source-${local.resource_suffix}"
  location      = var.region
  force_destroy = true
  
  labels = local.common_labels
  
  # Enable versioning for source code management
  versioning {
    enabled = true
  }
  
  # Configure lifecycle management
  lifecycle_rule {
    condition {
      age = 30
    }
    action {
      type = "Delete"
    }
  }
  
  depends_on = [google_project_service.required_apis]
}

# Create Cloud Function source code archive
data "archive_file" "function_source" {
  type        = "zip"
  output_path = "/tmp/function-source-${local.resource_suffix}.zip"
  
  source {
    filename = "main.py"
    content = <<-EOF
import json
import base64
import os
from datetime import datetime
import functions_framework
from google.cloud import logging

# Initialize Cloud Logging client
logging_client = logging.Client()
logging_client.setup_logging()

@functions_framework.cloud_event
def process_uptime_alert(cloud_event):
    """Process uptime monitoring alerts from Pub/Sub."""
    
    try:
        # Parse the Pub/Sub message
        message_data = cloud_event.data.get("message", {})
        
        # Decode base64 message data
        if "data" in message_data:
            decoded_data = base64.b64decode(message_data["data"]).decode("utf-8")
            alert_data = json.loads(decoded_data)
        else:
            alert_data = {}
        
        # Extract alert information from Cloud Monitoring format
        incident = alert_data.get("incident", {})
        policy_name = incident.get("policy_name", 
                     alert_data.get("policy", {}).get("displayName", "Unknown Policy"))
        condition_name = incident.get("condition_name", 
                        alert_data.get("condition", {}).get("displayName", "Unknown Condition"))
        state = incident.get("state", alert_data.get("state", "UNKNOWN"))
        started_at = incident.get("started_at", 
                    alert_data.get("startedAt", ""))
        url = incident.get("url", 
              alert_data.get("resource", {}).get("labels", {}).get("host", "Unknown URL"))
        
        # Format alert message
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")
        
        if state == "OPEN" or state == "FIRING":
            subject = f"🚨 Website Down Alert: {url}"
            status_emoji = "🚨"
            status_text = "DOWN"
            action_text = "Please investigate immediately"
        else:
            subject = f"✅ Website Restored: {url}"
            status_emoji = "✅"
            status_text = "RESTORED"
            action_text = "Service has been restored"
        
        # Create detailed message body
        message_body = f"""
Website Uptime Alert

{status_emoji} Status: {status_text}
🌐 Website: {url}
📋 Policy: {policy_name}
🔍 Condition: {condition_name}
⏰ Alert Time: {timestamp}
🕐 Started At: {started_at}

{action_text}

This alert was generated by Google Cloud Monitoring.
        """
        
        # Log alert details for debugging
        print(f"Processing alert for {url}: {state}")
        print(f"Subject: {subject}")
        print(f"Message body: {message_body}")
        
        # In production, integrate with your notification system here
        # Examples: send_email(), send_slack_message(), call_pagerduty()
        
        return {"status": "processed", "url": url, "state": state}
        
    except Exception as e:
        print(f"Error processing alert: {str(e)}")
        print(f"Raw cloud event data: {cloud_event.data}")
        return {"status": "error", "error": str(e)}
EOF
  }
  
  source {
    filename = "requirements.txt"
    content = <<-EOF
functions-framework==3.*
google-cloud-logging>=3.8.0
EOF
  }
}

# Upload Cloud Function source code to Cloud Storage
resource "google_storage_bucket_object" "function_source" {
  name   = "function-source-${local.resource_suffix}.zip"
  bucket = google_storage_bucket.function_source.name
  source = data.archive_file.function_source.output_path
  
  # Update the object when source code changes
  detect_md5hash = data.archive_file.function_source.output_md5
}

# Create Cloud Function for alert processing
resource "google_cloudfunctions2_function" "uptime_processor" {
  name     = "${var.resource_prefix}-processor-${local.resource_suffix}"
  location = var.region
  
  build_config {
    runtime     = "python312"
    entry_point = "process_uptime_alert"
    
    source {
      storage_source {
        bucket = google_storage_bucket.function_source.name
        object = google_storage_bucket_object.function_source.name
      }
    }
  }
  
  service_config {
    max_instance_count    = var.function_max_instances
    available_memory      = "${var.function_memory}Mi"
    timeout_seconds       = var.function_timeout
    service_account_email = google_service_account.function_sa.email
    
    environment_variables = {
      PROJECT_ID = var.project_id
      REGION     = var.region
    }
  }
  
  event_trigger {
    trigger_region = var.region
    event_type     = "google.cloud.pubsub.topic.v1.messagePublished"
    pubsub_topic   = google_pubsub_topic.uptime_alerts.id
    retry_policy   = "RETRY_POLICY_RETRY"
  }
  
  labels = local.common_labels
  
  depends_on = [
    google_project_service.required_apis,
    google_service_account.function_sa
  ]
}

# Create service account for Cloud Function
resource "google_service_account" "function_sa" {
  account_id   = "uptime-function-${local.resource_suffix}"
  display_name = "Cloud Function Service Account for Uptime Monitoring"
  description  = "Service account for the uptime alert processing Cloud Function"
}

# Grant necessary permissions to the Cloud Function service account
resource "google_project_iam_member" "function_sa_logging" {
  project = var.project_id
  role    = "roles/logging.logWriter"
  member  = "serviceAccount:${google_service_account.function_sa.email}"
}

resource "google_project_iam_member" "function_sa_pubsub" {
  project = var.project_id
  role    = "roles/pubsub.subscriber"
  member  = "serviceAccount:${google_service_account.function_sa.email}"
}

# Create notification channel for Pub/Sub alerts
resource "google_monitoring_notification_channel" "pubsub_alerts" {
  display_name = "${var.resource_prefix} Pub/Sub Channel"
  type         = "pubsub"
  description  = "Delivers uptime monitoring alerts to Pub/Sub topic"
  
  labels = {
    topic = google_pubsub_topic.uptime_alerts.id
  }
  
  user_labels = local.common_labels
  
  depends_on = [google_project_service.required_apis]
}

# Create uptime checks for each website
resource "google_monitoring_uptime_check_config" "website_checks" {
  for_each = toset(var.websites_to_monitor)
  
  display_name = "${var.resource_prefix}-check-${replace(replace(each.value, "https://", ""), "http://", "")}-${local.resource_suffix}"
  timeout      = "${var.uptime_check_timeout}s"
  period       = "${var.uptime_check_period}s"
  
  http_check {
    path           = "/"
    port           = 443
    request_method = "GET"
    use_ssl        = true
    validate_ssl   = true
    
    accepted_response_status_codes {
      status_class = "STATUS_CLASS_2XX"
    }
  }
  
  monitored_resource {
    type = "uptime_url"
    labels = {
      project_id = var.project_id
      host       = replace(replace(each.value, "https://", ""), "http://", "")
    }
  }
  
  # Configure checker locations for global monitoring
  dynamic "checker_type" {
    for_each = toset(["STATIC_IP_CHECKERS"])
    content {
      checker_type = checker_type.value
    }
  }
  
  selected_regions = var.checker_regions
  
  user_labels = merge(local.common_labels, {
    website = replace(replace(each.value, "https://", ""), "http://", "")
  })
  
  depends_on = [google_project_service.required_apis]
}

# Create alerting policy for uptime failures
resource "google_monitoring_alert_policy" "uptime_failures" {
  display_name = "${var.resource_prefix} Website Uptime Alert Policy"
  combiner     = "OR"
  enabled      = true
  
  documentation {
    content   = "Alert when websites fail uptime checks from multiple regions. Contact: ${var.notification_email}"
    mime_type = "text/markdown"
  }
  
  conditions {
    display_name = "Uptime check failures"
    
    condition_threshold {
      filter          = "resource.type=\"uptime_url\""
      duration        = "60s"
      comparison      = "COMPARISON_GREATER_THAN"
      threshold_value = var.alert_threshold_count
      
      aggregations {
        alignment_period     = "60s"
        per_series_aligner   = "ALIGN_NEXT_OLDER"
        cross_series_reducer = "REDUCE_COUNT_FALSE"
        
        group_by_fields = [
          "resource.label.host"
        ]
      }
      
      trigger {
        count = 1
      }
    }
  }
  
  # Configure alert strategy
  alert_strategy {
    auto_close = "${var.auto_close_duration}s"
    
    notification_rate_limit {
      period = "300s"
    }
  }
  
  notification_channels = [
    google_monitoring_notification_channel.pubsub_alerts.name
  ]
  
  user_labels = local.common_labels
  
  depends_on = [
    google_project_service.required_apis,
    google_monitoring_uptime_check_config.website_checks
  ]
}

# Create a dashboard for monitoring website uptime
resource "google_monitoring_dashboard" "uptime_dashboard" {
  dashboard_json = jsonencode({
    displayName = "${var.resource_prefix} Website Uptime Dashboard"
    
    mosaicLayout = {
      tiles = [
        {
          width  = 6
          height = 4
          widget = {
            title = "Website Availability"
            scorecard = {
              timeSeriesQuery = {
                timeSeriesFilter = {
                  filter = "resource.type=\"uptime_url\""
                  aggregation = {
                    alignmentPeriod    = "60s"
                    perSeriesAligner   = "ALIGN_FRACTION_TRUE"
                    crossSeriesReducer = "REDUCE_MEAN"
                    groupByFields      = ["resource.label.host"]
                  }
                }
              }
              sparkChartView = {
                sparkChartType = "SPARK_BAR"
              }
            }
          }
        },
        {
          width  = 6
          height = 4
          xPos   = 6
          widget = {
            title = "Response Time"
            xyChart = {
              dataSets = [
                {
                  timeSeriesQuery = {
                    timeSeriesFilter = {
                      filter = "resource.type=\"uptime_url\" AND metric.type=\"monitoring.googleapis.com/uptime_check/check_passed\""
                      aggregation = {
                        alignmentPeriod    = "60s"
                        perSeriesAligner   = "ALIGN_NEXT_OLDER"
                        crossSeriesReducer = "REDUCE_MEAN"
                        groupByFields      = ["resource.label.host"]
                      }
                    }
                  }
                  plotType = "LINE"
                }
              ]
              yAxis = {
                label = "Success Rate"
                scale = "LINEAR"
              }
            }
          }
        }
      ]
    }
  })
  
  depends_on = [
    google_project_service.required_apis,
    google_monitoring_uptime_check_config.website_checks
  ]
}